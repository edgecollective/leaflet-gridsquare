'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ensureArray = require('./ensure-array');

var _ensureArray2 = _interopRequireDefault(_ensureArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var noop = function noop() {};

var Controller = function () {

    // @param {object} io The socket.io-client module.


    // User-defined baud rates and ports
    function Controller(io) {
        _classCallCheck(this, Controller);

        this.io = null;
        this.socket = null;
        this.listeners = {
            // Socket.IO Events
            // Fired upon a connection including a successful reconnection.
            'connect': [],
            // Fired upon a connection error.
            'connect_error': [],
            // Fired upon a connection timeout.
            'connect_timeout': [],
            // Fired when an error occurs.
            'error': [],
            // Fired upon a disconnection.
            'disconnect': [],
            // Fired upon a successful reconnection.
            'reconnect': [],
            // Fired upon an attempt to reconnect.
            'reconnect_attempt': [],
            // Fired upon an attempt to reconnect.
            'reconnecting': [],
            // Fired upon a reconnection attempt error.
            'reconnect_error': [],
            // Fired when couldn't reconnect within reconnectionAttempts.
            'reconnect_failed': [],

            // System Events
            'startup': [],
            'config:change': [],
            'task:start': [],
            'task:finish': [],
            'task:error': [],
            'serialport:list': [],
            'serialport:change': [],
            'serialport:open': [],
            'serialport:close': [],
            'serialport:error': [],
            'serialport:read': [],
            'serialport:write': [],
            'gcode:load': [],
            'gcode:unload': [],
            'feeder:status': [],
            'sender:status': [],
            'workflow:state': [],
            'controller:settings': [],
            'controller:state': [],
            'message': []
        };
        this.context = {
            xmin: 0,
            xmax: 0,
            ymin: 0,
            ymax: 0,
            zmin: 0,
            zmax: 0
        };
        this.baudrates = [];
        this.ports = [];
        this.loadedControllers = [];
        this.port = '';
        this.type = '';
        this.settings = {};
        this.state = {};
        this.workflow = {
            state: 'idle' // running|paused|idle
        };

        if (!io) {
            throw new Error('Expected the socket.io-client module, but got: ' + io);
        }

        this.io = io;
    }
    // Whether or not the client is connected.
    // @return {boolean} Returns true if the client is connected, false otherwise.


    // Establish a connection to the server.
    // @param {string} host
    // @param {object} options
    // @param {function} next
    Controller.prototype.connect = function connect() {
        var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

        if (typeof next !== 'function') {
            next = noop;
        }

        this.socket && this.socket.destroy();
        this.socket = this.io.connect(host, options);

        Object.keys(this.listeners).forEach(function (eventName) {
            if (!_this.socket) {
                return;
            }

            _this.socket.on(eventName, function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                if (eventName === 'serialport:open') {
                    var _args$ = _extends({}, args[0]),
                        controllerType = _args$.controllerType,
                        port = _args$.port;

                    _this.port = port;
                    _this.type = controllerType;
                }
                if (eventName === 'serialport:close') {
                    _this.port = '';
                    _this.type = '';
                    _this.state = {};
                    _this.settings = {};
                    _this.workflow.state = 'idle';
                }
                if (eventName === 'workflow:state') {
                    _this.workflow.state = args[0];
                }
                if (eventName === 'controller:settings') {
                    _this.type = args[0];
                    _this.settings = _extends({}, args[1]);
                }
                if (eventName === 'controller:state') {
                    _this.type = args[0];
                    _this.state = _extends({}, args[1]);
                }

                var listeners = (0, _ensureArray2.default)(_this.listeners[eventName]);
                listeners.forEach(function (listener) {
                    listener.apply(undefined, args);
                });
            });
        });

        this.socket.on('startup', function (data) {
            var _data = _extends({}, data),
                loadedControllers = _data.loadedControllers,
                baudrates = _data.baudrates,
                ports = _data.ports;

            _this.loadedControllers = (0, _ensureArray2.default)(loadedControllers);

            // User-defined baud rates and ports
            _this.baudrates = (0, _ensureArray2.default)(baudrates);
            _this.ports = (0, _ensureArray2.default)(ports);

            if (next) {
                next(null);

                // The callback can only be called once
                next = null;
            }
        });
    };
    // Disconnect from the server.


    Controller.prototype.disconnect = function disconnect() {
        this.socket && this.socket.destroy();
        this.socket = null;
    };
    // Adds the `listener` function to the end of the listeners array for the event named `eventName`.
    // @param {string} eventName The name of the event.
    // @param {function} listener The listener function.


    Controller.prototype.addListener = function addListener(eventName, listener) {
        var listeners = this.listeners[eventName];
        if (!listeners || typeof listener !== 'function') {
            return false;
        }
        listeners.push(listener);
        return true;
    };
    // Removes the specified `listener` from the listener array for the event named `eventName`.
    // @param {string} eventName The name of the event.
    // @param {function} listener The listener function.


    Controller.prototype.removeListener = function removeListener(eventName, listener) {
        var listeners = this.listeners[eventName];
        if (!listeners || typeof listener !== 'function') {
            return false;
        }
        listeners.splice(listeners.indexOf(listener), 1);
        return true;
    };
    // Opens a connection to the given serial port.
    // @param {string} port The path of the serial port you want to open. For example, `dev/tty.XXX` on Mac and Linux, or `COM1` on Windows.
    // @param {object} [options] The options object.
    // @param {string} [options.controllerType] One of: 'Grbl', 'Smoothe', 'TinyG'. Defaults to 'Grbl'.
    // @param {number} [options.baudrate] Defaults to 115200.
    // @param {function} [callback] Called after a connection is opened.


    Controller.prototype.openPort = function openPort(port, options, callback) {
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
            options = {};
            callback = options;
        }
        if (typeof callback !== 'function') {
            callback = noop;
        }
        this.socket && this.socket.emit('open', port, options, callback);
    };
    // Closes an open connection.
    // @param {string} port The path of the serial port you want to close. For example, `dev/tty.XXX` on Mac and Linux, or `COM1` on Windows.
    // @param {function} [callback] Called once a connection is closed.


    Controller.prototype.closePort = function closePort(port, callback) {
        if (typeof callback !== 'function') {
            callback = noop;
        }
        this.socket && this.socket.emit('close', port, callback);
    };
    // Retrieves a list of available serial ports with metadata.
    // @param {function} [callback] Called once completed.


    Controller.prototype.listPorts = function listPorts(callback) {
        this.socket && this.socket.emit('list', callback);
    };
    // Executes a command on the server.
    // @param {string} cmd The command string
    // @example Example Usage
    // - Load G-code
    //   controller.command('gcode:load', name, gcode, context /* optional */, callback)
    // - Unload G-code
    //   controller.command('gcode:unload')
    // - Start sending G-code
    //   controller.command('gcode:start')
    // - Stop sending G-code
    //   controller.command('gcode:stop', { force: true })
    // - Pause
    //   controller.command('gcode:pause')
    // - Resume
    //   controller.command('gcode:resume')
    // - Feeder
    //   controller.command('feeder:feed')
    //   controller.command('feeder:start')
    //   controller.command('feeder:stop')
    //   controller.command('feeder:clear')
    // - Feed Hold
    //   controller.command('feedhold')
    // - Cycle Start
    //   controller.command('cyclestart')
    // - Status Report
    //   controller.command('statusreport')
    // - Homing
    //   controller.command('homing')
    // - Sleep
    //   controller.command('sleep')
    // - Unlock
    //   controller.command('unlock')
    // - Reset
    //   controller.command('reset')
    // - Feed Override
    //   controller.command('feedOverride')
    // - Spindle Override
    //   controller.command('spindleOverride')
    // - Rapid Override
    //   controller.command('rapidOverride')
    // - Energize Motors
    //   controller.command('energizeMotors:on')
    //   controller.command('energizeMotors:off')
    // - G-code
    //   controller.command('gcode', 'G0X0Y0', context /* optional */)
    // - Load a macro
    //   controller.command('macro:load', '<macro-id>', context /* optional */, callback)
    // - Run a macro
    //   controller.command('macro:run', '<macro-id>', context /* optional */, callback)
    // - Load file from a watch directory
    //   controller.command('watchdir:load', '/path/to/file', callback)


    Controller.prototype.command = function command(cmd) {
        var port = this.port;

        if (!port) {
            return;
        }

        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
        }

        this.socket && this.socket.emit.apply(this.socket, ['command', port, cmd].concat(args));
    };
    // Writes data to the serial port.
    // @param {string} data The data to write.
    // @param {object} [context] The associated context information.


    Controller.prototype.write = function write(data, context) {
        var port = this.port;

        if (!port) {
            return;
        }
        this.socket && this.socket.emit('write', port, data, context);
    };
    // Writes data and a newline character to the serial port.
    // @param {string} data The data to write.
    // @param {object} [context] The associated context information.


    Controller.prototype.writeln = function writeln(data, context) {
        var port = this.port;

        if (!port) {
            return;
        }
        this.socket && this.socket.emit('writeln', port, data, context);
    };

    _createClass(Controller, [{
        key: 'connected',
        get: function get() {
            return !!(this.socket && this.socket.connected);
        }
    }]);

    return Controller;
}();

exports.default = Controller;