"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseStringSync = exports.parseString = exports.parseFileSync = exports.parseFile = exports.parseStream = exports.parseLine = exports.GCodeLineStream = void 0;

var _events = _interopRequireDefault(require("events"));

var _fs = _interopRequireDefault(require("fs"));

var _timers = _interopRequireDefault(require("timers"));

var _stream = _interopRequireWildcard(require("stream"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var noop = function noop() {};

var streamify = function streamify(text) {
  var s = new _stream["default"].Readable();
  s.push(text);
  s.push(null);
  return s;
};

var containsLineEnd = function () {
  var re = new RegExp(/.*(?:\r\n|\r|\n)/g);
  return function (s) {
    return !!s.match(re);
  };
}(); // @param {array} arr The array to iterate over.
// @param {object} opts The options object.
// @param {function} iteratee The iteratee invoked per element.
// @param {function} done The done invoked after the loop has finished.


var iterateArray = function iterateArray() {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var iteratee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;
  var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;

  if (typeof opts === 'function') {
    done = iteratee;
    iteratee = opts;
    opts = {};
  }

  opts.batchSize = opts.batchSize || 1;

  var loop = function loop() {
    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    for (var count = 0; i < arr.length && count < opts.batchSize; ++i, ++count) {
      iteratee(arr[i], i, arr);
    }

    if (i < arr.length) {
      _timers["default"].setImmediate(function () {
        return loop(i);
      });

      return;
    }

    done();
  };

  loop();
}; // @param {string} line The G-code line


var parseLine = function () {
  // http://reprap.org/wiki/G-code#Special_fields
  // The checksum "cs" for a GCode string "cmd" (including its line number) is computed
  // by exor-ing the bytes in the string up to and not including the * character.
  var computeChecksum = function computeChecksum(s) {
    s = s || '';

    if (s.lastIndexOf('*') >= 0) {
      s = s.substr(0, s.lastIndexOf('*'));
    }

    var cs = 0;

    for (var i = 0; i < s.length; ++i) {
      var c = s[i].charCodeAt(0);
      cs ^= c;
    }

    return cs;
  }; // http://linuxcnc.org/docs/html/gcode/overview.html#gcode:comments
  // Comments can be embedded in a line using parentheses () or for the remainder of a lineusing a semi-colon. The semi-colon is not treated as the start of a comment when enclosed in parentheses.


  var stripComments = function () {
    var re1 = new RegExp(/\s*\([^\)]*\)/g); // Remove anything inside the parentheses

    var re2 = new RegExp(/\s*;.*/g); // Remove anything after a semi-colon to the end of the line, including preceding spaces

    var re3 = new RegExp(/\s+/g);
    return function (line) {
      return line.replace(re1, '').replace(re2, '').replace(re3, '');
    };
  }();

  var re = /(%.*)|({.*)|((?:\$\$)|(?:\$[a-zA-Z0-9#]*))|([a-zA-Z][0-9\+\-\.]+)|(\*[0-9]+)/igm;
  return function (line, options) {
    options = options || {};
    options.flatten = !!options.flatten;
    options.noParseLine = !!options.noParseLine;
    var result = {
      line: line
    };

    if (options.noParseLine) {
      return result;
    }

    result.words = [];
    var ln; // Line number

    var cs; // Checksum

    var words = stripComments(line).match(re) || [];

    for (var i = 0; i < words.length; ++i) {
      var word = words[i];
      var letter = word[0].toUpperCase();
      var argument = word.slice(1); // Parse % commands for bCNC and CNCjs
      // - %wait Wait until the planner queue is empty

      if (letter === '%') {
        result.cmds = (result.cmds || []).concat(line.trim());
        continue;
      } // Parse JSON commands for TinyG and g2core


      if (letter === '{') {
        result.cmds = (result.cmds || []).concat(line.trim());
        continue;
      } // Parse $ commands for Grbl
      // - $C Check gcode mode
      // - $H Run homing cycle


      if (letter === '$') {
        result.cmds = (result.cmds || []).concat("".concat(letter).concat(argument));
        continue;
      } // N: Line number


      if (letter === 'N' && typeof ln === 'undefined') {
        // Line (block) number in program
        ln = Number(argument);
        continue;
      } // *: Checksum


      if (letter === '*' && typeof cs === 'undefined') {
        cs = Number(argument);
        continue;
      }

      var value = Number(argument);

      if (Number.isNaN(value)) {
        value = argument;
      }

      if (options.flatten) {
        result.words.push(letter + value);
      } else {
        result.words.push([letter, value]);
      }
    } // Line number


    typeof ln !== 'undefined' && (result.ln = ln); // Checksum

    typeof cs !== 'undefined' && (result.cs = cs);

    if (result.cs && computeChecksum(line) !== result.cs) {
      result.err = true; // checksum failed
    }

    return result;
  };
}(); // @param {object} stream The G-code line stream
// @param {options} options The options object
// @param {function} callback The callback function


exports.parseLine = parseLine;

var parseStream = function parseStream(stream, options) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  var emitter = new _events["default"].EventEmitter();

  try {
    var results = [];
    stream.pipe(new GCodeLineStream(options)).on('data', function (data) {
      emitter.emit('data', data);
      results.push(data);
    }).on('end', function () {
      emitter.emit('end', results);
      callback && callback(null, results);
    }).on('error', callback);
  } catch (err) {
    callback(err);
  }

  return emitter;
}; // @param {string} file The G-code path name
// @param {options} options The options object
// @param {function} callback The callback function


exports.parseStream = parseStream;

var parseFile = function parseFile(file, options) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  file = file || '';

  var s = _fs["default"].createReadStream(file, {
    encoding: 'utf8'
  });

  s.on('error', callback);
  return parseStream(s, options, callback);
};

exports.parseFile = parseFile;

var parseFileSync = function parseFileSync(file, options) {
  return parseStringSync(_fs["default"].readFileSync(file, 'utf8'), options);
}; // @param {string} str The G-code text string
// @param {options} options The options object
// @param {function} callback The callback function


exports.parseFileSync = parseFileSync;

var parseString = function parseString(str, options) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  return parseStream(streamify(str), options, callback);
};

exports.parseString = parseString;

var parseStringSync = function parseStringSync(str, options) {
  var _options = _objectSpread({}, options),
      _options$flatten = _options.flatten,
      flatten = _options$flatten === void 0 ? false : _options$flatten,
      _options$noParseLine = _options.noParseLine,
      noParseLine = _options$noParseLine === void 0 ? false : _options$noParseLine;

  var results = [];
  var lines = str.split('\n');

  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i].trim();

    if (line.length === 0) {
      continue;
    }

    var result = parseLine(line, {
      flatten: flatten,
      noParseLine: noParseLine
    });
    results.push(result);
  }

  return results;
}; // @param {string} str The G-code text string
// @param {options} options The options object


exports.parseStringSync = parseStringSync;

var GCodeLineStream =
/*#__PURE__*/
function (_Transform) {
  _inherits(GCodeLineStream, _Transform);

  // @param {object} [options] The options object
  // @param {number} [options.batchSize] The batch size.
  // @param {boolean} [options.flatten] True to flatten the array, false otherwise.
  // @param {boolean} [options.noParseLine] True to not parse line, false otherwise.
  function GCodeLineStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GCodeLineStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GCodeLineStream).call(this, {
      objectMode: true
    }));

    _defineProperty(_assertThisInitialized(_this), "state", {
      lineCount: 0,
      lastChunkEndedWithCR: false
    });

    _defineProperty(_assertThisInitialized(_this), "options", {
      batchSize: 1000,
      noParseLine: false
    });

    _defineProperty(_assertThisInitialized(_this), "lineBuffer", '');

    _defineProperty(_assertThisInitialized(_this), "re", new RegExp(/.*(?:\r\n|\r|\n)|.+$/g));

    _this.options = _objectSpread({}, _this.options, options);
    return _this;
  }

  _createClass(GCodeLineStream, [{
    key: "_transform",
    value: function _transform(chunk, encoding, next) {
      var _this2 = this;

      // decode binary chunks as UTF-8
      encoding = encoding || 'utf8';

      if (Buffer.isBuffer(chunk)) {
        if (encoding === 'buffer') {
          encoding = 'utf8';
        }

        chunk = chunk.toString(encoding);
      }

      this.lineBuffer += chunk;

      if (!containsLineEnd(chunk)) {
        next();
        return;
      }

      var lines = this.lineBuffer.match(this.re);

      if (!lines || lines.length === 0) {
        next();
        return;
      } // Do not split CRLF which spans chunks


      if (this.state.lastChunkEndedWithCR && lines[0] === '\n') {
        lines.shift();
      }

      this.state.lastChunkEndedWithCR = this.lineBuffer[this.lineBuffer.length - 1] === '\r';

      if (this.lineBuffer[this.lineBuffer.length - 1] === '\r' || this.lineBuffer[this.lineBuffer.length - 1] === '\n') {
        this.lineBuffer = '';
      } else {
        var line = lines.pop() || '';
        this.lineBuffer = line;
      }

      iterateArray(lines, {
        batchSize: this.options.batchSize
      }, function (line, key) {
        line = line.trim();

        if (line.length > 0) {
          var result = parseLine(line, {
            flatten: _this2.options.flatten,
            noParseLine: _this2.options.noParseLine
          });

          _this2.push(result);
        }
      }, next);
    }
  }, {
    key: "_flush",
    value: function _flush(done) {
      if (this.lineBuffer) {
        var line = this.lineBuffer.trim();

        if (line.length > 0) {
          var result = parseLine(line, {
            flatten: this.options.flatten,
            noParseLine: this.options.noParseLine
          });
          this.push(result);
        }

        this.lineBuffer = '';
        this.state.lastChunkEndedWithCR = false;
      }

      done();
    }
  }]);

  return GCodeLineStream;
}(_stream.Transform);

exports.GCodeLineStream = GCodeLineStream;