"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createServer = void 0;

var _dns = _interopRequireDefault(require("dns"));

var _fs = _interopRequireDefault(require("fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _bcryptNodejs = _interopRequireDefault(require("bcrypt-nodejs"));

var _chalk = _interopRequireDefault(require("chalk"));

var _ensureArray = _interopRequireDefault(require("ensure-array"));

var _expandTilde = _interopRequireDefault(require("expand-tilde"));

var _express = _interopRequireDefault(require("express"));

var _httpProxy = _interopRequireDefault(require("http-proxy"));

var _escapeRegExp = _interopRequireDefault(require("lodash/escapeRegExp"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _set = _interopRequireDefault(require("lodash/set"));

var _size = _interopRequireDefault(require("lodash/size"));

var _trimEnd = _interopRequireDefault(require("lodash/trimEnd"));

var _uniqWith = _interopRequireDefault(require("lodash/uniqWith"));

var _webappengine = _interopRequireDefault(require("webappengine"));

var _settings = _interopRequireDefault(require("./config/settings"));

var _app = _interopRequireDefault(require("./app"));

var _cncengine = _interopRequireDefault(require("./services/cncengine"));

var _monitor = _interopRequireDefault(require("./services/monitor"));

var _configstore = _interopRequireDefault(require("./services/configstore"));

var _ensureType = require("./lib/ensure-type");

var _logger = _interopRequireWildcard(require("./lib/logger"));

var _urljoin = _interopRequireDefault(require("./lib/urljoin"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var log = (0, _logger["default"])('init');

var createServer = function createServer(options, callback) {
  options = _objectSpread({}, options);
  {
    // verbosity
    var verbosity = options.verbosity; // https://github.com/winstonjs/winston#logging-levels

    if (verbosity === 1) {
      (0, _set["default"])(_settings["default"], 'verbosity', verbosity);
      (0, _logger.setLevel)('verbose');
    }

    if (verbosity === 2) {
      (0, _set["default"])(_settings["default"], 'verbosity', verbosity);
      (0, _logger.setLevel)('debug');
    }

    if (verbosity === 3) {
      (0, _set["default"])(_settings["default"], 'verbosity', verbosity);
      (0, _logger.setLevel)('silly');
    }
  }

  var rcfile = _path["default"].resolve(options.configFile || _settings["default"].rcfile); // configstore service


  log.info("Loading configuration from ".concat(_chalk["default"].yellow(JSON.stringify(rcfile))));

  _configstore["default"].load(rcfile); // rcfile


  _settings["default"].rcfile = rcfile;
  {
    // secret
    if (!_configstore["default"].get('secret')) {
      // generate a secret key
      var secret = _bcryptNodejs["default"].genSaltSync(); // TODO: use a strong secret


      _configstore["default"].set('secret', secret);
    }

    _settings["default"].secret = _configstore["default"].get('secret', _settings["default"].secret);
  }
  {
    // watchDirectory
    var watchDirectory = options.watchDirectory || _configstore["default"].get('watchDirectory');

    if (watchDirectory) {
      if (_fs["default"].existsSync(watchDirectory)) {
        log.info("Watching ".concat(_chalk["default"].yellow(JSON.stringify(watchDirectory)), " for file changes")); // monitor service

        _monitor["default"].start({
          watchDirectory: watchDirectory
        });
      } else {
        log.error("The directory ".concat(_chalk["default"].yellow(JSON.stringify(watchDirectory)), " does not exist."));
      }
    }
  }
  {
    // accessTokenLifetime
    var accessTokenLifetime = options.accessTokenLifetime || _configstore["default"].get('accessTokenLifetime');

    if (accessTokenLifetime) {
      (0, _set["default"])(_settings["default"], 'accessTokenLifetime', accessTokenLifetime);
    }
  }
  {
    // allowRemoteAccess
    var allowRemoteAccess = options.allowRemoteAccess || _configstore["default"].get('allowRemoteAccess', false);

    if (allowRemoteAccess) {
      if ((0, _size["default"])(_configstore["default"].get('users')) === 0) {
        log.warn('You\'ve enabled remote access to the server. It\'s recommended to create an user account to protect against malicious attacks.');
      }

      (0, _set["default"])(_settings["default"], 'allowRemoteAccess', allowRemoteAccess);
    }
  }
  var _options = options,
      _options$port = _options.port,
      port = _options$port === void 0 ? 0 : _options$port,
      host = _options.host,
      backlog = _options.backlog;
  var mountPoints = (0, _uniqWith["default"])([].concat(_toConsumableArray((0, _ensureArray["default"])(options.mountPoints)), _toConsumableArray((0, _ensureArray["default"])(_configstore["default"].get('mountPoints')))), _isEqual["default"]).filter(function (mount) {
    if (!mount || !mount.route || mount.route === '/') {
      log.error("Must specify a valid route path ".concat(JSON.stringify(mount.route), "."));
      return false;
    }

    return true;
  });
  var routes = [];
  mountPoints.forEach(function (mount) {
    if ((0, _ensureType.ensureString)(mount.target).match(/^(http|https):\/\//i)) {
      log.info("Starting a proxy server to proxy all requests starting with ".concat(_chalk["default"].yellow(mount.route), " to ").concat(_chalk["default"].yellow(mount.target)));
      routes.push({
        type: 'server',
        route: mount.route,
        server: function server(options) {
          // route
          // > '/custom-widget/'
          // routeWithoutTrailingSlash
          // > '/custom-widget'
          // target
          // > 'https://cncjs.github.io/cncjs-widget-boilerplate/'
          // targetPathname
          // > '/cncjs-widget-boilerplate/'
          // proxyPathPattern
          // > RegExp('^/cncjs-widget-boilerplate/custom-widget')
          var _options2 = _objectSpread({}, options),
              _options2$route = _options2.route,
              route = _options2$route === void 0 ? '/' : _options2$route;

          var routeWithoutTrailingSlash = (0, _trimEnd["default"])(route, '/');
          var target = mount.target;

          var targetPathname = _url["default"].parse(target).pathname;

          var proxyPathPattern = new RegExp('^' + (0, _escapeRegExp["default"])((0, _urljoin["default"])(targetPathname, routeWithoutTrailingSlash)), 'i');
          log.debug("> route=".concat(_chalk["default"].yellow(route)));
          log.debug("> routeWithoutTrailingSlash=".concat(_chalk["default"].yellow(routeWithoutTrailingSlash)));
          log.debug("> target=".concat(_chalk["default"].yellow(target)));
          log.debug("> targetPathname=".concat(_chalk["default"].yellow(targetPathname)));
          log.debug("> proxyPathPattern=RegExp(".concat(_chalk["default"].yellow(proxyPathPattern), ")"));

          var proxy = _httpProxy["default"].createProxyServer({
            // Change the origin of the host header to the target URL
            changeOrigin: true,
            // Do not verify the SSL certificate for self-signed certs
            //secure: false,
            target: target
          });

          proxy.on('proxyReq', function (proxyReq, req, res, options) {
            var originalPath = proxyReq.path || '';
            proxyReq.path = originalPath.replace(proxyPathPattern, targetPathname).replace('//', '/');
            log.debug("proxy.on('proxyReq'): modifiedPath=".concat(_chalk["default"].yellow(proxyReq.path), ", originalPath=").concat(_chalk["default"].yellow(originalPath)));
          });
          proxy.on('proxyRes', function (proxyRes, req, res) {
            log.debug("proxy.on('proxyRes'): headers=".concat(JSON.stringify(proxyRes.headers, true, 2)));
          });
          var app = (0, _express["default"])(); // Matched routes:
          //   /widget/
          //   /widget/v1/

          app.all((0, _urljoin["default"])(routeWithoutTrailingSlash, '*'), function (req, res) {
            var url = req.url;
            log.debug("proxy.web(): url=".concat(_chalk["default"].yellow(url)));
            proxy.web(req, res);
          }); // Matched routes:
          //   /widget

          app.all(routeWithoutTrailingSlash, function (req, res, next) {
            var url = req.url; // Redirect URL with a trailing slash

            if (url.indexOf(routeWithoutTrailingSlash) === 0 && url.indexOf(routeWithoutTrailingSlash + '/') < 0) {
              var redirectUrl = routeWithoutTrailingSlash + '/' + url.slice(routeWithoutTrailingSlash.length);
              log.debug("redirect: url=".concat(_chalk["default"].yellow(url), ", redirectUrl=").concat(_chalk["default"].yellow(redirectUrl)));
              res.redirect(301, redirectUrl);
              return;
            }

            next();
          });
          return app;
        }
      });
    } else {
      // expandTilde('~') => '/Users/<userhome>'
      var directory = (0, _expandTilde["default"])((0, _ensureType.ensureString)(mount.target)).trim();
      log.info("Mounting a directory ".concat(_chalk["default"].yellow(JSON.stringify(directory)), " to serve requests starting with ").concat(_chalk["default"].yellow(mount.route)));

      if (!directory) {
        log.error("The directory path ".concat(_chalk["default"].yellow(JSON.stringify(directory)), " must not be empty."));
        return;
      }

      if (!_path["default"].isAbsolute(directory)) {
        log.error("The directory path ".concat(_chalk["default"].yellow(JSON.stringify(directory)), " must be absolute."));
        return;
      }

      if (!_fs["default"].existsSync(directory)) {
        log.error("The directory path ".concat(_chalk["default"].yellow(JSON.stringify(directory)), " does not exist."));
        return;
      }

      routes.push({
        type: 'static',
        route: mount.route,
        directory: directory
      });
    }
  });
  routes.push({
    type: 'server',
    route: '/',
    server: function server() {
      return (0, _app["default"])();
    }
  });
  (0, _webappengine["default"])({
    port: port,
    host: host,
    backlog: backlog,
    routes: routes
  }).on('ready', function (server) {
    // cncengine service
    _cncengine["default"].start(server, options.controller || _configstore["default"].get('controller', ''));

    var address = server.address().address;
    var port = server.address().port;
    callback && callback(null, {
      address: address,
      port: port,
      mountPoints: mountPoints
    });

    if (address !== '0.0.0.0') {
      log.info('Starting the server at ' + _chalk["default"].yellow("http://".concat(address, ":").concat(port)));
      return;
    }

    _dns["default"].lookup(_os["default"].hostname(), {
      family: 4,
      all: true
    }, function (err, addresses) {
      if (err) {
        log.error('Can\'t resolve host name:', err);
        return;
      }

      addresses.forEach(function (_ref) {
        var address = _ref.address,
            family = _ref.family;
        log.info('Starting the server at ' + _chalk["default"].yellow("http://".concat(address, ":").concat(port)));
      });
    });
  }).on('error', function (err) {
    callback && callback(err);
    log.error(err);
  });
};

exports.createServer = createServer;