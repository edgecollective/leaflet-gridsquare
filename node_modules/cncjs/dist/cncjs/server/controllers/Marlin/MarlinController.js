"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _ensureArray = _interopRequireDefault(require("ensure-array"));

var parser = _interopRequireWildcard(require("gcode-parser"));

var _SerialConnection = _interopRequireDefault(require("../../lib/SerialConnection"));

var _EventTrigger = _interopRequireDefault(require("../../lib/EventTrigger"));

var _Feeder = _interopRequireDefault(require("../../lib/Feeder"));

var _Sender = _interopRequireWildcard(require("../../lib/Sender"));

var _Workflow = _interopRequireWildcard(require("../../lib/Workflow"));

var _ensurePositiveNumber = _interopRequireDefault(require("../../lib/ensure-positive-number"));

var _evaluateAssignmentExpression = _interopRequireDefault(require("../../lib/evaluate-assignment-expression"));

var _logger = _interopRequireDefault(require("../../lib/logger"));

var _translateExpression = _interopRequireDefault(require("../../lib/translate-expression"));

var _configstore = _interopRequireDefault(require("../../services/configstore"));

var _monitor = _interopRequireDefault(require("../../services/monitor"));

var _taskrunner = _interopRequireDefault(require("../../services/taskrunner"));

var _store = _interopRequireDefault(require("../../store"));

var _constants = require("../constants");

var _MarlinRunner = _interopRequireDefault(require("./MarlinRunner"));

var _interpret = _interopRequireDefault(require("./interpret"));

var _constants2 = require("./constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// % commands
var WAIT = '%wait';
var log = (0, _logger["default"])('controller:Marlin');
var noop = _noop2["default"];

var MarlinController = /*#__PURE__*/function () {
  // CNCEngine
  // Sockets
  // Connection
  // Marlin
  // Event Trigger
  // Feeder
  // Sender
  // Shared context
  // Workflow
  // Query
  // Get the current position of the active nozzle and stepper values.
  // Request a temperature report to be sent to the host at some point in the future.
  function MarlinController(engine, options) {
    var _this = this;

    _classCallCheck(this, MarlinController);

    _defineProperty(this, "type", _constants2.MARLIN);

    _defineProperty(this, "engine", null);

    _defineProperty(this, "sockets", {});

    _defineProperty(this, "connection", null);

    _defineProperty(this, "connectionEventListener", {
      data: function data(_data) {
        log.silly("< ".concat(_data));

        _this.runner.parse('' + _data);
      },
      close: function close(err) {
        _this.ready = false;

        if (err) {
          log.warn("Disconnected from serial port \"".concat(_this.options.port, "\":"), err);
        }

        _this.close(function (err) {
          // Remove controller from store
          var port = _this.options.port;

          _store["default"].unset("controllers[".concat(JSON.stringify(port), "]")); // Destroy controller


          _this.destroy();
        });
      },
      error: function error(err) {
        _this.ready = false;

        if (err) {
          log.error("Unexpected error while reading/writing serial port \"".concat(_this.options.port, "\":"), err);
        }
      }
    });

    _defineProperty(this, "controller", null);

    _defineProperty(this, "ready", false);

    _defineProperty(this, "state", {});

    _defineProperty(this, "settings", {});

    _defineProperty(this, "feedOverride", 100);

    _defineProperty(this, "spindleOverride", 100);

    _defineProperty(this, "history", {
      // The write source is one of the following:
      // * WRITE_SOURCE_CLIENT
      // * WRITE_SOURCE_SERVER
      // * WRITE_SOURCE_FEEDER
      // * WRITE_SOURCE_SENDER
      writeSource: null,
      writeLine: ''
    });

    _defineProperty(this, "event", null);

    _defineProperty(this, "feeder", null);

    _defineProperty(this, "sender", null);

    _defineProperty(this, "senderFinishTime", 0);

    _defineProperty(this, "sharedContext", {});

    _defineProperty(this, "workflow", null);

    _defineProperty(this, "queryTimer", null);

    _defineProperty(this, "query", {
      // state
      type: null,
      lastQueryTime: 0,
      // action
      issue: function issue() {
        if (!_this.query.type) {
          return;
        }

        var now = new Date().getTime();

        if (_this.query.type === _constants2.QUERY_TYPE_POSITION) {
          _this.connection.write('M114\n', {
            source: _constants.WRITE_SOURCE_SERVER
          });

          _this.query.lastQueryTime = now;
        } else if (_this.query.type === _constants2.QUERY_TYPE_TEMPERATURE) {
          _this.connection.write('M105\n', {
            source: _constants.WRITE_SOURCE_SERVER
          });

          _this.query.lastQueryTime = now;
        } else {
          log.error('Unsupported query type:', _this.query.type);
        }

        _this.query.type = null;
      }
    });

    _defineProperty(this, "queryPosition", function () {
      var lastQueryTime = 0;
      return (0, _throttle2["default"])(function () {
        // Check the ready flag
        if (!_this.ready) {
          return;
        }

        var now = new Date().getTime();

        if (!_this.query.type) {
          _this.query.type = _constants2.QUERY_TYPE_POSITION;
          lastQueryTime = now;
        } else if (lastQueryTime > 0) {
          var timespan = Math.abs(now - lastQueryTime);
          var toleranceTime = 5000; // 5 seconds

          if (timespan >= toleranceTime) {
            log.silly("Reschedule current position query: now=".concat(now, "ms, timespan=").concat(timespan, "ms"));
            _this.query.type = _constants2.QUERY_TYPE_POSITION;
            lastQueryTime = now;
          }
        }
      }, 500);
    }());

    _defineProperty(this, "queryTemperature", function () {
      var lastQueryTime = 0;
      return (0, _throttle2["default"])(function () {
        // Check the ready flag
        if (!_this.ready) {
          return;
        }

        var now = new Date().getTime();

        if (!_this.query.type) {
          _this.query.type = _constants2.QUERY_TYPE_TEMPERATURE;
          lastQueryTime = now;
        } else if (lastQueryTime > 0) {
          var timespan = Math.abs(now - lastQueryTime);
          var toleranceTime = 10000; // 10 seconds

          if (timespan >= toleranceTime) {
            log.silly("Reschedule temperture report query: now=".concat(now, "ms, timespan=").concat(timespan, "ms"));
            _this.query.type = _constants2.QUERY_TYPE_TEMPERATURE;
            lastQueryTime = now;
          }
        }
      }, 1000);
    }());

    if (!engine) {
      throw new Error('engine must be specified');
    }

    this.engine = engine;

    var _options = _objectSpread({}, options),
        _port = _options.port,
        baudrate = _options.baudrate,
        rtscts = _options.rtscts;

    this.options = _objectSpread(_objectSpread({}, this.options), {}, {
      port: _port,
      baudrate: baudrate,
      rtscts: rtscts
    }); // Connection

    this.connection = new _SerialConnection["default"]({
      path: _port,
      baudRate: baudrate,
      rtscts: rtscts,
      writeFilter: function writeFilter(data, context) {
        var _context = _objectSpread({}, context),
            _context$source = _context.source,
            source = _context$source === void 0 ? null : _context$source;

        var line = data.trim(); // Update write history

        _this.history.writeSource = source;
        _this.history.writeLine = line;

        if (!line) {
          return data;
        }

        var nextState = _objectSpread(_objectSpread({}, _this.runner.state), {}, {
          modal: _objectSpread({}, _this.runner.state.modal)
        });

        (0, _interpret["default"])(line, function (cmd, params) {
          // motion
          if ((0, _includes2["default"])(['G0', 'G1', 'G2', 'G3', 'G38.2', 'G38.3', 'G38.4', 'G38.5', 'G80'], cmd)) {
            nextState.modal.motion = cmd;

            if (params.F !== undefined) {
              if (cmd === 'G0') {
                nextState.rapidFeedrate = params.F;
              } else {
                nextState.feedrate = params.F;
              }
            }
          } // wcs


          if ((0, _includes2["default"])(['G54', 'G55', 'G56', 'G57', 'G58', 'G59'], cmd)) {
            nextState.modal.wcs = cmd;
          } // plane


          if ((0, _includes2["default"])(['G17', 'G18', 'G19'], cmd)) {
            // G17: xy-plane, G18: xz-plane, G19: yz-plane
            nextState.modal.plane = cmd;
          } // units


          if ((0, _includes2["default"])(['G20', 'G21'], cmd)) {
            // G20: Inches, G21: Millimeters
            nextState.modal.units = cmd;
          } // distance


          if ((0, _includes2["default"])(['G90', 'G91'], cmd)) {
            // G90: Absolute, G91: Relative
            nextState.modal.distance = cmd;
          } // feedrate


          if ((0, _includes2["default"])(['G93', 'G94'], cmd)) {
            // G93: Inverse time mode, G94: Units per minute
            nextState.modal.feedrate = cmd;
          } // program


          if ((0, _includes2["default"])(['M0', 'M1', 'M2', 'M30'], cmd)) {
            nextState.modal.program = cmd;
          } // spindle or head


          if ((0, _includes2["default"])(['M3', 'M4', 'M5'], cmd)) {
            // M3: Spindle (cw), M4: Spindle (ccw), M5: Spindle off
            nextState.modal.spindle = cmd;

            if (cmd === 'M3' || cmd === 'M4') {
              if (params.S !== undefined) {
                nextState.spindle = params.S;
              }
            }
          } // coolant


          if ((0, _includes2["default"])(['M7', 'M8', 'M9'], cmd)) {
            var coolant = nextState.modal.coolant; // M7: Mist coolant, M8: Flood coolant, M9: Coolant off, [M7,M8]: Both on

            if (cmd === 'M9' || coolant === 'M9') {
              nextState.modal.coolant = cmd;
            } else {
              nextState.modal.coolant = (0, _uniq2["default"])((0, _ensureArray["default"])(coolant).concat(cmd)).sort();

              if (nextState.modal.coolant.length === 1) {
                nextState.modal.coolant = nextState.modal.coolant[0];
              }
            }
          }
        });

        if (!(0, _isEqual2["default"])(_this.runner.state, nextState)) {
          _this.runner.state = nextState; // enforce change
        }

        return data;
      }
    }); // Event Trigger

    this.event = new _EventTrigger["default"](function (event, trigger, commands) {
      log.debug("EventTrigger: event=\"".concat(event, "\", trigger=\"").concat(trigger, "\", commands=\"").concat(commands, "\""));

      if (trigger === 'system') {
        _taskrunner["default"].run(commands);
      } else {
        _this.command('gcode', commands);
      }
    }); // Feeder

    this.feeder = new _Feeder["default"]({
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug('Wait for the planner to empty'); // G4 [P<time in ms>] [S<time in sec>]
            // If both S and P are included, S takes precedence.

            return 'G4 P500'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words); // M109 Set extruder temperature and wait for the target temperature to be reached

        if ((0, _includes2["default"])(words, 'M109')) {
          log.debug("Wait for extruder temperature to reach target temperature (".concat(line, ")"));

          _this.feeder.hold({
            data: 'M109'
          }); // Hold reason

        } // M190 Set heated bed temperature and wait for the target temperature to be reached


        if ((0, _includes2["default"])(words, 'M190')) {
          log.debug("Wait for heated bed temperature to reach target temperature (".concat(line, ")"));

          _this.feeder.hold({
            data: 'M190'
          }); // Hold reason

        }

        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug('M0 Program Pause');

            _this.feeder.hold({
              data: 'M0'
            }); // Hold reason

          } else if (programMode === 'M1') {
            log.debug('M1 Program Pause');

            _this.feeder.hold({
              data: 'M1'
            }); // Hold reason

          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug('M6 Tool Change');

          _this.feeder.hold({
            data: 'M6'
          }); // Hold reason

        }

        return line;
      }
    });
    this.feeder.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.runner.isAlarm()) {
        _this.feeder.reset();

        log.warn('Stopped sending G-code commands in Alarm mode');
        return;
      }

      line = String(line).trim();

      if (line.length === 0) {
        return;
      }

      _this.emit('serialport:write', line + '\n', _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_FEEDER
      }));

      _this.connection.write(line + '\n', {
        source: _constants.WRITE_SOURCE_FEEDER
      });

      log.silly("> ".concat(line));
    });
    this.feeder.on('hold', noop);
    this.feeder.on('unhold', noop); // Sender

    this.sender = new _Sender["default"](_Sender.SP_TYPE_SEND_RESPONSE, {
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);
        var _this$sender$state = _this.sender.state,
            sent = _this$sender$state.sent,
            received = _this$sender$state.received;

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug("Wait for the planner to empty: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.sender.hold({
              data: WAIT
            }); // Hold reason
            // G4 [P<time in ms>] [S<time in sec>]
            // If both S and P are included, S takes precedence.


            return 'G4 P500'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words); // M109 Set extruder temperature and wait for the target temperature to be reached

        if ((0, _includes2["default"])(words, 'M109')) {
          log.debug("Wait for extruder temperature to reach target temperature (".concat(line, "): line=").concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));
          var reason = {
            data: 'M109'
          };

          _this.sender.hold(reason); // Hold reason

        } // M190 Set heated bed temperature and wait for the target temperature to be reached


        if ((0, _includes2["default"])(words, 'M190')) {
          log.debug("Wait for heated bed temperature to reach target temperature (".concat(line, "): line=").concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));
          var _reason = {
            data: 'M190'
          };

          _this.sender.hold(_reason); // Hold reason

        }

        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug("M0 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M0'
            });
          } else if (programMode === 'M1') {
            log.debug("M1 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M1'
            });
          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug("M6 Tool Change: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

          _this.workflow.pause({
            data: 'M6'
          });
        }

        return line;
      }
    });
    this.sender.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE) {
        log.error("Unexpected workflow state: ".concat(_this.workflow.state));
        return;
      }

      line = String(line).trim();

      if (line.length === 0) {
        log.warn("Expected non-empty line: N=".concat(_this.sender.state.sent));
        return;
      }

      _this.connection.write(line + '\n', {
        source: _constants.WRITE_SOURCE_SENDER
      });

      log.silly("> ".concat(line));
    });
    this.sender.on('hold', noop);
    this.sender.on('unhold', noop);
    this.sender.on('start', function (startTime) {
      _this.senderFinishTime = 0;
    });
    this.sender.on('end', function (finishTime) {
      _this.senderFinishTime = finishTime;
    }); // Workflow

    this.workflow = new _Workflow["default"]();
    this.workflow.on('start', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.sender.rewind();
    });
    this.workflow.on('stop', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.sender.rewind();
    });
    this.workflow.on('pause', function () {
      _this.emit('workflow:state', _this.workflow.state);

      if (arguments.length > 0) {
        var reason = _objectSpread({}, arguments.length <= 0 ? undefined : arguments[0]);

        _this.sender.hold(reason); // Hold reason

      } else {
        _this.sender.hold();
      }
    });
    this.workflow.on('resume', function () {
      _this.emit('workflow:state', _this.workflow.state); // Reset feeder prior to resume program execution


      _this.feeder.reset(); // Resume program execution


      _this.sender.unhold();

      _this.sender.next();
    }); // Marlin

    this.runner = new _MarlinRunner["default"]();
    this.runner.on('raw', noop);
    this.runner.on('start', function (res) {
      _this.emit('serialport:read', res.raw); // Marlin sends 'start' as the first message after
      // power-on, but not when the serial port is closed and
      // then re-opened.  Marlin has no software-initiated
      // restart, so 'start' is not dependable as a readiness
      // indicator.  Instead, we send M115 on connection open
      // to request a firmware report, whose response signals
      // Marlin readiness.  On initial power-up, Marlin might
      // miss that first M115 as it boots, so we send this
      // possibly-redundant M115 when we see 'start'.


      _this.connection.write('M115\n', {
        source: _constants.WRITE_SOURCE_SERVER
      });
    });
    this.runner.on('echo', function (res) {
      _this.emit('serialport:read', res.raw);
    });
    this.runner.on('firmware', function (res) {
      _this.emit('serialport:read', res.raw);

      if (!_this.ready) {
        _this.ready = true; // Initialize controller

        _this.event.trigger('controller:ready');
      }
    });
    this.runner.on('pos', function (res) {
      log.silly("controller.on('pos'): source=".concat(_this.history.writeSource, ", line=").concat(JSON.stringify(_this.history.writeLine), ", res=").concat(JSON.stringify(res)));

      if ((0, _includes2["default"])([_constants.WRITE_SOURCE_CLIENT, _constants.WRITE_SOURCE_FEEDER], _this.history.writeSource)) {
        _this.emit('serialport:read', res.raw);
      }
    });
    this.runner.on('temperature', function (res) {
      log.silly("controller.on('temperature'): source=".concat(_this.history.writeSource, ", line=").concat(JSON.stringify(_this.history.writeLine), ", res=").concat(JSON.stringify(res)));

      if ((0, _includes2["default"])([_constants.WRITE_SOURCE_CLIENT, _constants.WRITE_SOURCE_FEEDER], _this.history.writeSource)) {
        _this.emit('serialport:read', res.raw);
      }
    });
    this.runner.on('ok', function (res) {
      log.silly("controller.on('ok'): source=".concat(_this.history.writeSource, ", line=").concat(JSON.stringify(_this.history.writeLine), ", res=").concat(JSON.stringify(res)));

      if (res) {
        if ((0, _includes2["default"])([_constants.WRITE_SOURCE_CLIENT, _constants.WRITE_SOURCE_FEEDER], _this.history.writeSource)) {
          _this.emit('serialport:read', res.raw);
        } else if (!_this.history.writeSource) {
          _this.emit('serialport:read', res.raw);

          log.error('"history.writeSource" should not be empty');
        }
      }

      _this.history.writeSource = null;
      _this.history.writeLine = ''; // Perform preemptive query to prevent starvation

      var now = new Date().getTime();
      var timespan = Math.abs(now - _this.query.lastQueryTime);

      if (_this.query.type && timespan > 2000) {
        _this.query.issue();

        return;
      }

      var _this$sender$state2 = _this.sender.state,
          hold = _this$sender$state2.hold,
          sent = _this$sender$state2.sent,
          received = _this$sender$state2.received;

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        if (hold && received + 1 >= sent) {
          log.debug("Continue sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received + 1));

          _this.sender.unhold();
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_PAUSED && received < sent) {
        if (!hold) {
          log.error('The sender does not hold off during the paused state');
        }

        if (received + 1 >= sent) {
          log.debug("Stop sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received + 1));
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      } // Feeder


      if (_this.feeder.next()) {
        return;
      }

      _this.query.issue();
    });
    this.runner.on('error', function (res) {
      // Sender
      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        var ignoreErrors = _configstore["default"].get('state.controller.exception.ignoreErrors');

        var pauseError = !ignoreErrors;
        var _this$sender$state3 = _this.sender.state,
            lines = _this$sender$state3.lines,
            received = _this$sender$state3.received;
        var line = lines[received] || '';

        _this.emit('serialport:read', "> ".concat(line.trim(), " (line=").concat(received + 1, ")"));

        _this.emit('serialport:read', res.raw);

        if (pauseError) {
          _this.workflow.pause({
            err: res.raw
          });
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      }

      _this.emit('serialport:read', res.raw); // Feeder


      _this.feeder.next();
    });
    this.runner.on('others', function (res) {
      _this.emit('serialport:read', res.raw);
    });
    this.queryTimer = setInterval(function () {
      if (_this.isClose()) {
        // Serial port is closed
        return;
      } // Feeder


      if (_this.feeder.peek()) {
        _this.emit('feeder:status', _this.feeder.toJSON());
      } // Sender


      if (_this.sender.peek()) {
        _this.emit('sender:status', _this.sender.toJSON());
      }

      var zeroOffset = (0, _isEqual2["default"])(_this.runner.getPosition(_this.state), _this.runner.getPosition(_this.runner.state)); // Marlin settings

      if (_this.settings !== _this.runner.settings) {
        _this.settings = _this.runner.settings;

        _this.emit('controller:settings', _constants2.MARLIN, _this.settings);

        _this.emit('Marlin:settings', _this.settings); // Backward compatibility

      } // Marlin state


      if (_this.state !== _this.runner.state) {
        _this.state = _this.runner.state;

        _this.emit('controller:state', _constants2.MARLIN, _this.state);

        _this.emit('Marlin:state', _this.state); // Backward compatibility

      } // Check the ready flag


      if (!_this.ready) {
        return;
      } // M114: Get Current Position


      _this.queryPosition(); // M105: Report Temperatures


      _this.queryTemperature();

      {
        // The following criteria must be met to issue a query
        var notBusy = !_this.history.writeSource;
        var senderIdle = _this.sender.state.sent === _this.sender.state.received;
        var feederEmpty = _this.feeder.size() === 0;

        if (notBusy && senderIdle && feederEmpty) {
          _this.query.issue();
        }
      } // Check if the machine has stopped movement after completion

      if (_this.senderFinishTime > 0) {
        var machineIdle = zeroOffset;
        var now = new Date().getTime();
        var timespan = Math.abs(now - _this.senderFinishTime);
        var toleranceTime = 500; // in milliseconds

        if (!machineIdle) {
          // Extend the sender finish time
          _this.senderFinishTime = now;
        } else if (timespan > toleranceTime) {
          log.silly("Finished sending G-code: timespan=".concat(timespan));
          _this.senderFinishTime = 0; // Stop workflow

          _this.command('gcode:stop');
        }
      }
    }, 250);
  }

  _createClass(MarlinController, [{
    key: "populateContext",
    value: function populateContext(context) {
      // Work position
      var _this$runner$getPosit = this.runner.getPosition(),
          posx = _this$runner$getPosit.x,
          posy = _this$runner$getPosit.y,
          posz = _this$runner$getPosit.z,
          pose = _this$runner$getPosit.e; // Modal group


      var modal = this.runner.getModalGroup(); // Tool

      var tool = this.runner.getTool();
      return Object.assign(context || {}, _objectSpread({
        // User-defined global variables
        global: this.sharedContext,
        // Bounding box
        xmin: Number(context.xmin) || 0,
        xmax: Number(context.xmax) || 0,
        ymin: Number(context.ymin) || 0,
        ymax: Number(context.ymax) || 0,
        zmin: Number(context.zmin) || 0,
        zmax: Number(context.zmax) || 0,
        // Work position
        posx: Number(posx) || 0,
        posy: Number(posy) || 0,
        posz: Number(posz) || 0,
        pose: Number(pose) || 0,
        // Modal group
        modal: {
          motion: modal.motion,
          wcs: modal.wcs,
          plane: modal.plane,
          units: modal.units,
          distance: modal.distance,
          feedrate: modal.feedrate,
          program: modal.program,
          spindle: modal.spindle,
          // M7 and M8 may be active at the same time, but a modal group violation might occur when issuing M7 and M8 together on the same line. Using the new line character (\n) to separate lines can avoid this issue.
          coolant: (0, _ensureArray["default"])(modal.coolant).join('\n')
        },
        // Tool
        tool: Number(tool) || 0
      }, _constants.GLOBAL_OBJECTS));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.queryTimer) {
        clearInterval(this.queryTimer);
        this.queryTimer = null;
      }

      if (this.runner) {
        this.runner.removeAllListeners();
        this.runner = null;
      }

      this.sockets = {};

      if (this.connection) {
        this.connection = null;
      }

      if (this.event) {
        this.event = null;
      }

      if (this.feeder) {
        this.feeder = null;
      }

      if (this.sender) {
        this.sender = null;
      }

      if (this.workflow) {
        this.workflow = null;
      }
    }
  }, {
    key: "status",
    get: function get() {
      return {
        port: this.options.port,
        baudrate: this.options.baudrate,
        rtscts: this.options.rtscts,
        sockets: Object.keys(this.sockets),
        ready: this.ready,
        controller: {
          type: this.type,
          settings: this.settings,
          state: this.state
        },
        feeder: this.feeder.toJSON(),
        sender: this.sender.toJSON(),
        workflow: {
          state: this.workflow.state
        }
      };
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;
      var _this$options = this.options,
          port = _this$options.port,
          baudrate = _this$options.baudrate; // Assertion check

      if (this.isOpen()) {
        log.error("Cannot open serial port \"".concat(port, "\""));
        return;
      }

      this.connection.on('data', this.connectionEventListener.data);
      this.connection.on('close', this.connectionEventListener.close);
      this.connection.on('error', this.connectionEventListener.error);
      this.connection.open(function (err) {
        if (err) {
          log.error("Error opening serial port \"".concat(port, "\":"), err);

          _this2.emit('serialport:error', {
            err: err,
            port: port
          });

          callback(err); // notify error

          return;
        }

        _this2.emit('serialport:open', {
          port: port,
          baudrate: baudrate,
          controllerType: _this2.type,
          inuse: true
        }); // Emit a change event to all connected sockets


        if (_this2.engine.io) {
          _this2.engine.io.emit('serialport:change', {
            port: port,
            inuse: true
          });
        }

        callback(); // register controller

        log.debug("Connected to serial port \"".concat(port, "\"")); // M115: Get firmware version and capabilities
        // The response to this will take us to the ready state

        _this2.connection.write('M115\n', {
          source: _constants.WRITE_SOURCE_SERVER
        });

        _this2.workflow.stop();

        if (_this2.sender.state.gcode) {
          // Unload G-code
          _this2.command('unload');
        }
      });
    }
  }, {
    key: "close",
    value: function close(callback) {
      var port = this.options.port; // Assertion check

      if (!this.connection) {
        var err = "Serial port \"".concat(port, "\" is not available");
        callback(new Error(err));
        return;
      } // Stop status query


      this.ready = false;
      this.emit('serialport:close', {
        port: port,
        inuse: false
      }); // Emit a change event to all connected sockets

      if (this.engine.io) {
        this.engine.io.emit('serialport:change', {
          port: port,
          inuse: false
        });
      }

      if (this.isClose()) {
        callback(null);
        return;
      }

      this.connection.removeAllListeners();
      this.connection.close(callback);
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.connection && this.connection.isOpen;
    }
  }, {
    key: "isClose",
    value: function isClose() {
      return !this.isOpen();
    }
  }, {
    key: "addConnection",
    value: function addConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Add socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = socket; //
      // Send data to newly connected client
      //

      if (this.isOpen()) {
        socket.emit('serialport:open', {
          port: this.options.port,
          baudrate: this.options.baudrate,
          controllerType: this.type,
          inuse: true
        });
      }

      if (!(0, _isEmpty2["default"])(this.settings)) {
        // controller settings
        socket.emit('controller:settings', _constants2.MARLIN, this.settings);
        socket.emit('Marlin:settings', this.settings); // Backward compatibility
      }

      if (!(0, _isEmpty2["default"])(this.state)) {
        // controller state
        socket.emit('controller:state', _constants2.MARLIN, this.state);
        socket.emit('Marlin:state', this.state); // Backward compatibility
      }

      if (this.feeder) {
        // feeder status
        socket.emit('feeder:status', this.feeder.toJSON());
      }

      if (this.sender) {
        // sender status
        socket.emit('sender:status', this.sender.toJSON());
        var _this$sender$state4 = this.sender.state,
            name = _this$sender$state4.name,
            gcode = _this$sender$state4.gcode,
            context = _this$sender$state4.context;

        if (gcode) {
          socket.emit('gcode:load', name, gcode, context);
        }
      }

      if (this.workflow) {
        // workflow state
        socket.emit('workflow:state', this.workflow.state);
      }
    }
  }, {
    key: "removeConnection",
    value: function removeConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Remove socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = undefined;
      delete this.sockets[socket.id];
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this3 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      Object.keys(this.sockets).forEach(function (id) {
        var socket = _this3.sockets[id];
        socket.emit.apply(socket, [eventName].concat(args));
      });
    }
  }, {
    key: "command",
    value: function command(cmd) {
      var _this4 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var handler = {
        'gcode:load': function gcodeLoad() {
          var name = args[0],
              gcode = args[1],
              _args$ = args[2],
              context = _args$ === void 0 ? {} : _args$,
              _args$2 = args[3],
              callback = _args$2 === void 0 ? noop : _args$2;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          } // G4 P0 or P with a very small value will empty the planner queue and then
          // respond with an ok when the dwell is complete. At that instant, there will
          // be no queued motions, as long as no more commands were sent after the G4.
          // This is the fastest way to do it without having to check the status reports.


          var dwell = '%wait ; Wait for the planner to empty';

          var ok = _this4.sender.load(name, gcode + '\n' + dwell, context);

          if (!ok) {
            callback(new Error("Invalid G-code: name=".concat(name)));
            return;
          }

          _this4.emit('gcode:load', name, gcode, context);

          _this4.event.trigger('gcode:load');

          log.debug("Load G-code: name=\"".concat(_this4.sender.state.name, "\", size=").concat(_this4.sender.state.gcode.length, ", total=").concat(_this4.sender.state.total));

          _this4.workflow.stop();

          callback(null, _this4.sender.toJSON());
        },
        'gcode:unload': function gcodeUnload() {
          _this4.workflow.stop(); // Sender


          _this4.sender.unload();

          _this4.emit('gcode:unload');

          _this4.event.trigger('gcode:unload');
        },
        'start': function start() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:start');
        },
        'gcode:start': function gcodeStart() {
          _this4.event.trigger('gcode:start');

          _this4.workflow.start(); // Feeder


          _this4.feeder.reset(); // Sender


          _this4.sender.next();
        },
        'stop': function stop() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command.apply(_this4, ['gcode:stop'].concat(args));
        },
        // @param {object} options The options object.
        // @param {boolean} [options.force] Whether to force stop a G-code program. Defaults to false.
        'gcode:stop': function gcodeStop() {
          _this4.event.trigger('gcode:stop');

          _this4.workflow.stop();
        },
        'pause': function pause() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:pause');
        },
        'gcode:pause': function gcodePause() {
          _this4.event.trigger('gcode:pause');

          _this4.workflow.pause();
        },
        'resume': function resume() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:resume');
        },
        'gcode:resume': function gcodeResume() {
          _this4.event.trigger('gcode:resume');

          _this4.workflow.resume();
        },
        'feeder:feed': function feederFeed() {
          var commands = args[0],
              _args$3 = args[1],
              context = _args$3 === void 0 ? {} : _args$3;

          _this4.command('gcode', commands, context);
        },
        'feeder:start': function feederStart() {
          if (_this4.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
            return;
          }

          _this4.feeder.unhold();

          _this4.feeder.next();
        },
        'feeder:stop': function feederStop() {
          _this4.feeder.reset();
        },
        'feedhold': function feedhold() {
          _this4.event.trigger('feedhold');
        },
        'cyclestart': function cyclestart() {
          _this4.event.trigger('cyclestart');
        },
        'homing': function homing() {
          _this4.event.trigger('homing');

          _this4.writeln('G28.2 X Y Z');
        },
        'sleep': function sleep() {
          _this4.event.trigger('sleep'); // Unupported

        },
        'unlock': function unlock() {// Unsupported
        },
        'reset': function reset() {
          _this4.workflow.stop();

          _this4.feeder.reset(); // M112: Emergency Stop


          _this4.writeln('M112');
        },
        // Feed Overrides
        // @param {number} value A percentage value between 10 and 500. A value of zero will reset to 100%.
        'feedOverride': function feedOverride() {
          var value = args[0];
          var feedOverride = _this4.runner.state.ovF;

          if (value === 0) {
            feedOverride = 100;
          } else if (feedOverride + value > 500) {
            feedOverride = 500;
          } else if (feedOverride + value < 10) {
            feedOverride = 10;
          } else {
            feedOverride += value;
          } // M220: Set speed factor override percentage


          _this4.command('gcode', 'M220S' + feedOverride); // enforce state change


          _this4.runner.state = _objectSpread(_objectSpread({}, _this4.runner.state), {}, {
            ovF: feedOverride
          });
        },
        // Spindle Speed Overrides
        // @param {number} value A percentage value between 10 and 500. A value of zero will reset to 100%.
        'spindleOverride': function spindleOverride() {
          var value = args[0];
          var spindleOverride = _this4.runner.state.ovS;

          if (value === 0) {
            spindleOverride = 100;
          } else if (spindleOverride + value > 500) {
            spindleOverride = 500;
          } else if (spindleOverride + value < 10) {
            spindleOverride = 10;
          } else {
            spindleOverride += value;
          } // M221: Set extruder factor override percentage


          _this4.command('gcode', 'M221S' + spindleOverride); // enforce state change


          _this4.runner.state = _objectSpread(_objectSpread({}, _this4.runner.state), {}, {
            ovS: spindleOverride
          });
        },
        'rapidOverride': function rapidOverride() {// Unsupported
        },
        'motor:enable': function motorEnable() {
          // M17 Enable all stepper motors
          _this4.command('gcode', 'M17');
        },
        'motor:disable': function motorDisable() {
          // M18/M84 Disable steppers immediately (until the next move)
          _this4.command('gcode', 'M18');
        },
        'laser:on': function laserOn() {
          var _args$4 = args[0],
              power = _args$4 === void 0 ? 0 : _args$4,
              _args$5 = args[1],
              maxS = _args$5 === void 0 ? 255 : _args$5;
          var commands = ['M3S' + (0, _ensurePositiveNumber["default"])(maxS * (power / 100))];

          _this4.command('gcode', commands);
        },
        'lasertest:on': function lasertestOn() {
          var _args$6 = args[0],
              power = _args$6 === void 0 ? 0 : _args$6,
              _args$7 = args[1],
              duration = _args$7 === void 0 ? 0 : _args$7,
              _args$8 = args[2],
              maxS = _args$8 === void 0 ? 255 : _args$8;
          var commands = ['M3S' + (0, _ensurePositiveNumber["default"])(maxS * (power / 100))];

          if (duration > 0) {
            // G4 [P<time in ms>] [S<time in sec>]
            // If both S and P are included, S takes precedence.
            commands.push('G4 P' + (0, _ensurePositiveNumber["default"])(duration));
            commands.push('M5');
          }

          _this4.command('gcode', commands);
        },
        'lasertest:off': function lasertestOff() {
          _this4.writeln('M5');
        },
        'gcode': function gcode() {
          var commands = args[0],
              context = args[1];
          var data = (0, _ensureArray["default"])(commands).join('\n').split(/\r?\n/).filter(function (line) {
            if (typeof line !== 'string') {
              return false;
            }

            return line.trim().length > 0;
          });

          _this4.feeder.feed(data, context);

          {
            // The following criteria must be met to trigger the feeder
            var notBusy = !_this4.history.writeSource;
            var senderIdle = _this4.sender.state.sent === _this4.sender.state.received;
            var feederIdle = !_this4.feeder.isPending();

            if (notBusy && senderIdle && feederIdle) {
              _this4.feeder.next();
            }
          }
        },
        'macro:run': function macroRun() {
          var id = args[0],
              _args$9 = args[1],
              context = _args$9 === void 0 ? {} : _args$9,
              _args$10 = args[2],
              callback = _args$10 === void 0 ? noop : _args$10;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this4.event.trigger('macro:run');

          _this4.command('gcode', macro.content, context);

          callback(null);
        },
        'macro:load': function macroLoad() {
          var id = args[0],
              _args$11 = args[1],
              context = _args$11 === void 0 ? {} : _args$11,
              _args$12 = args[2],
              callback = _args$12 === void 0 ? noop : _args$12;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this4.event.trigger('macro:load');

          _this4.command('gcode:load', macro.name, macro.content, context, callback);
        },
        'watchdir:load': function watchdirLoad() {
          var file = args[0],
              _args$13 = args[1],
              callback = _args$13 === void 0 ? noop : _args$13;
          var context = {}; // empty context

          _monitor["default"].readFile(file, function (err, data) {
            if (err) {
              callback(err);
              return;
            }

            _this4.command('gcode:load', file, data, context, callback);
          });
        }
      }[cmd];

      if (!handler) {
        log.error("Unknown command: ".concat(cmd));
        return;
      }

      handler();
    }
  }, {
    key: "write",
    value: function write(data, context) {
      // Assertion check
      if (this.isClose()) {
        log.error("Serial port \"".concat(this.options.port, "\" is not accessible"));
        return;
      }

      this.emit('serialport:write', data, _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_CLIENT
      }));
      this.connection.write(data, {
        source: _constants.WRITE_SOURCE_CLIENT
      });
      log.silly("> ".concat(data));
    }
  }, {
    key: "writeln",
    value: function writeln(data, context) {
      this.write(data + '\n', context);
    }
  }]);

  return MarlinController;
}();

var _default = MarlinController;
exports["default"] = _default;