"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _find2 = _interopRequireDefault(require("lodash/find"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _ensureArray = _interopRequireDefault(require("ensure-array"));

var parser = _interopRequireWildcard(require("gcode-parser"));

var _SerialConnection = _interopRequireDefault(require("../../lib/SerialConnection"));

var _EventTrigger = _interopRequireDefault(require("../../lib/EventTrigger"));

var _Feeder = _interopRequireDefault(require("../../lib/Feeder"));

var _Sender = _interopRequireWildcard(require("../../lib/Sender"));

var _Workflow = _interopRequireWildcard(require("../../lib/Workflow"));

var _delay = _interopRequireDefault(require("../../lib/delay"));

var _ensurePositiveNumber = _interopRequireDefault(require("../../lib/ensure-positive-number"));

var _evaluateAssignmentExpression = _interopRequireDefault(require("../../lib/evaluate-assignment-expression"));

var _logger = _interopRequireDefault(require("../../lib/logger"));

var _translateExpression = _interopRequireDefault(require("../../lib/translate-expression"));

var _configstore = _interopRequireDefault(require("../../services/configstore"));

var _monitor = _interopRequireDefault(require("../../services/monitor"));

var _taskrunner = _interopRequireDefault(require("../../services/taskrunner"));

var _store = _interopRequireDefault(require("../../store"));

var _constants = require("../constants");

var _GrblRunner = _interopRequireDefault(require("./GrblRunner"));

var _constants2 = require("./constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// % commands
var WAIT = '%wait';
var log = (0, _logger["default"])('controller:Grbl');
var noop = _noop2["default"];

var GrblController = /*#__PURE__*/function () {
  // CNCEngine
  // Sockets
  // Connection
  // Grbl
  // Event Trigger
  // Feeder
  // Sender
  // Shared context
  // Workflow
  function GrblController(engine, options) {
    var _this = this;

    _classCallCheck(this, GrblController);

    _defineProperty(this, "type", _constants2.GRBL);

    _defineProperty(this, "engine", null);

    _defineProperty(this, "sockets", {});

    _defineProperty(this, "connection", null);

    _defineProperty(this, "connectionEventListener", {
      data: function data(_data) {
        log.silly("< ".concat(_data));

        _this.runner.parse('' + _data);
      },
      close: function close(err) {
        _this.ready = false;

        if (err) {
          log.warn("Disconnected from serial port \"".concat(_this.options.port, "\":"), err);
        }

        _this.close(function (err) {
          // Remove controller from store
          var port = _this.options.port;

          _store["default"].unset("controllers[".concat(JSON.stringify(port), "]")); // Destroy controller


          _this.destroy();
        });
      },
      error: function error(err) {
        _this.ready = false;

        if (err) {
          log.error("Unexpected error while reading/writing serial port \"".concat(_this.options.port, "\":"), err);
        }
      }
    });

    _defineProperty(this, "controller", null);

    _defineProperty(this, "ready", false);

    _defineProperty(this, "initialized", false);

    _defineProperty(this, "state", {});

    _defineProperty(this, "settings", {});

    _defineProperty(this, "queryTimer", null);

    _defineProperty(this, "actionMask", {
      queryParserState: {
        state: false,
        // wait for a message containing the current G-code parser modal state
        reply: false // wait for an `ok` or `error` response

      },
      queryStatusReport: false,
      // Respond to user input
      replyParserState: false,
      // $G
      replyStatusReport: false // ?

    });

    _defineProperty(this, "actionTime", {
      queryParserState: 0,
      queryStatusReport: 0,
      senderFinishTime: 0
    });

    _defineProperty(this, "event", null);

    _defineProperty(this, "feeder", null);

    _defineProperty(this, "sender", null);

    _defineProperty(this, "sharedContext", {});

    _defineProperty(this, "workflow", null);

    if (!engine) {
      throw new Error('engine must be specified');
    }

    this.engine = engine;

    var _options = _objectSpread({}, options),
        _port = _options.port,
        baudrate = _options.baudrate,
        rtscts = _options.rtscts;

    this.options = _objectSpread(_objectSpread({}, this.options), {}, {
      port: _port,
      baudrate: baudrate,
      rtscts: rtscts
    }); // Connection

    this.connection = new _SerialConnection["default"]({
      path: _port,
      baudRate: baudrate,
      rtscts: rtscts,
      writeFilter: function writeFilter(data) {
        var line = data.trim();

        if (!line) {
          return data;
        }

        {
          // Grbl settings: $0-$255
          var r = line.match(/^(\$\d{1,3})=([\d\.]+)$/);

          if (r) {
            var name = r[1];
            var value = Number(r[2]);

            if (name === '$13' && value >= 0 && value <= 65535) {
              var nextSettings = _objectSpread(_objectSpread({}, _this.runner.settings), {}, {
                settings: _objectSpread(_objectSpread({}, _this.runner.settings.settings), {}, _defineProperty({}, name, value ? '1' : '0'))
              });

              _this.runner.settings = nextSettings; // enforce change
            }
          }
        }
        return data;
      }
    }); // Event Trigger

    this.event = new _EventTrigger["default"](function (event, trigger, commands) {
      log.debug("EventTrigger: event=\"".concat(event, "\", trigger=\"").concat(trigger, "\", commands=\"").concat(commands, "\""));

      if (trigger === 'system') {
        _taskrunner["default"].run(commands);
      } else {
        _this.command('gcode', commands);
      }
    }); // Feeder

    this.feeder = new _Feeder["default"]({
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug('Wait for the planner to empty');
            return 'G4 P0.5'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words);
        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug('M0 Program Pause');

            _this.feeder.hold({
              data: 'M0'
            }); // Hold reason

          } else if (programMode === 'M1') {
            log.debug('M1 Program Pause');

            _this.feeder.hold({
              data: 'M1'
            }); // Hold reason

          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug('M6 Tool Change');

          _this.feeder.hold({
            data: 'M6'
          }); // Hold reason
          // Surround M6 with parentheses to ignore
          // unsupported command error. If we nuke the whole
          // line, then we'll likely lose other commands that
          // share the line, like a T~.  This makes tool
          // changes complicated.


          line = line.replace('M6', '(M6)');
        }

        return line;
      }
    });
    this.feeder.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.runner.isAlarm()) {
        _this.feeder.reset();

        log.warn('Stopped sending G-code commands in Alarm mode');
        return;
      }

      line = String(line).trim();

      if (line.length === 0) {
        return;
      }

      _this.emit('serialport:write', line + '\n', _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_FEEDER
      }));

      _this.connection.write(line + '\n');

      log.silly("> ".concat(line));
    });
    this.feeder.on('hold', noop);
    this.feeder.on('unhold', noop); // Sender

    this.sender = new _Sender["default"](_Sender.SP_TYPE_CHAR_COUNTING, {
      // Deduct the buffer size to prevent from buffer overrun
      bufferSize: 128 - 8,
      // The default buffer size is 128 bytes
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);
        var _this$sender$state = _this.sender.state,
            sent = _this$sender$state.sent,
            received = _this$sender$state.received;

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug("Wait for the planner to empty: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.sender.hold({
              data: WAIT
            }); // Hold reason


            return 'G4 P0.5'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words);
        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug("M0 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M0'
            });
          } else if (programMode === 'M1') {
            log.debug("M1 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M1'
            });
          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug("M6 Tool Change: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

          _this.workflow.pause({
            data: 'M6'
          }); // Surround M6 with parentheses to ignore unsupported command error


          line = line.replace('M6', '(M6)');
        }

        return line;
      }
    });
    this.sender.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE) {
        log.error("Unexpected workflow state: ".concat(_this.workflow.state));
        return;
      }

      line = String(line).trim();

      if (line.length === 0) {
        log.warn("Expected non-empty line: N=".concat(_this.sender.state.sent));
        return;
      }

      _this.connection.write(line + '\n');

      log.silly("> ".concat(line));
    });
    this.sender.on('hold', noop);
    this.sender.on('unhold', noop);
    this.sender.on('start', function (startTime) {
      _this.actionTime.senderFinishTime = 0;
    });
    this.sender.on('end', function (finishTime) {
      _this.actionTime.senderFinishTime = finishTime;
    }); // Workflow

    this.workflow = new _Workflow["default"]();
    this.workflow.on('start', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.sender.rewind();
    });
    this.workflow.on('stop', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.sender.rewind();
    });
    this.workflow.on('pause', function () {
      _this.emit('workflow:state', _this.workflow.state);

      if (arguments.length > 0) {
        var reason = _objectSpread({}, arguments.length <= 0 ? undefined : arguments[0]);

        _this.sender.hold(reason); // Hold reason

      } else {
        _this.sender.hold();
      }
    });
    this.workflow.on('resume', function () {
      _this.emit('workflow:state', _this.workflow.state); // Reset feeder prior to resume program execution


      _this.feeder.reset(); // Resume program execution


      _this.sender.unhold();

      _this.sender.next();
    }); // Grbl

    this.runner = new _GrblRunner["default"]();
    this.runner.on('raw', noop);
    this.runner.on('status', function (res) {
      _this.actionMask.queryStatusReport = false;

      if (_this.actionMask.replyStatusReport) {
        _this.actionMask.replyStatusReport = false;

        _this.emit('serialport:read', res.raw);
      } // Check if the receive buffer is available in the status report
      // @see https://github.com/cncjs/cncjs/issues/115
      // @see https://github.com/cncjs/cncjs/issues/133


      var rx = Number((0, _get2["default"])(res, 'buf.rx', 0)) || 0;

      if (rx > 0) {
        // Do not modify the buffer size when running a G-code program
        if (_this.workflow.state !== _Workflow.WORKFLOW_STATE_IDLE) {
          return;
        } // Check if the streaming protocol is character-counting streaming protocol


        if (_this.sender.sp.type !== _Sender.SP_TYPE_CHAR_COUNTING) {
          return;
        } // Check if the queue is empty


        if (_this.sender.sp.dataLength !== 0) {
          return;
        } // Deduct the receive buffer length to prevent from buffer overrun


        var bufferSize = rx - 8; // TODO

        if (bufferSize > _this.sender.sp.bufferSize) {
          _this.sender.sp.bufferSize = bufferSize;
        }
      }
    });
    this.runner.on('ok', function (res) {
      if (_this.actionMask.queryParserState.reply) {
        if (_this.actionMask.replyParserState) {
          _this.actionMask.replyParserState = false;

          _this.emit('serialport:read', res.raw);
        }

        _this.actionMask.queryParserState.reply = false;
        return;
      }

      var _this$sender$state2 = _this.sender.state,
          hold = _this$sender$state2.hold,
          sent = _this$sender$state2.sent,
          received = _this$sender$state2.received;

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        if (hold && received + 1 >= sent) {
          log.debug("Continue sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received + 1));

          _this.sender.unhold();
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_PAUSED && received < sent) {
        if (!hold) {
          log.error('The sender does not hold off during the paused state');
        }

        if (received + 1 >= sent) {
          log.debug("Stop sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received + 1));
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      }

      _this.emit('serialport:read', res.raw); // Feeder


      _this.feeder.next();
    });
    this.runner.on('error', function (res) {
      var code = Number(res.message) || undefined;
      var error = (0, _find2["default"])(_constants2.GRBL_ERRORS, {
        code: code
      });

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        var ignoreErrors = _configstore["default"].get('state.controller.exception.ignoreErrors');

        var pauseError = !ignoreErrors;
        var _this$sender$state3 = _this.sender.state,
            lines = _this$sender$state3.lines,
            received = _this$sender$state3.received;
        var line = lines[received] || '';

        _this.emit('serialport:read', "> ".concat(line.trim(), " (line=").concat(received + 1, ")"));

        if (error) {
          // Grbl v1.1
          _this.emit('serialport:read', "error:".concat(code, " (").concat(error.message, ")"));

          if (pauseError) {
            _this.workflow.pause({
              err: "error:".concat(code, " (").concat(error.message, ")")
            });
          }
        } else {
          // Grbl v0.9
          _this.emit('serialport:read', res.raw);

          if (pauseError) {
            _this.workflow.pause({
              err: res.raw
            });
          }
        }

        _this.sender.ack();

        _this.sender.next();

        return;
      }

      if (error) {
        // Grbl v1.1
        _this.emit('serialport:read', "error:".concat(code, " (").concat(error.message, ")"));
      } else {
        // Grbl v0.9
        _this.emit('serialport:read', res.raw);
      } // Feeder


      _this.feeder.next();
    });
    this.runner.on('alarm', function (res) {
      var code = Number(res.message) || undefined;
      var alarm = (0, _find2["default"])(_constants2.GRBL_ALARMS, {
        code: code
      });

      if (alarm) {
        // Grbl v1.1
        _this.emit('serialport:read', "ALARM:".concat(code, " (").concat(alarm.message, ")"));
      } else {
        // Grbl v0.9
        _this.emit('serialport:read', res.raw);
      }
    });
    this.runner.on('parserstate', function (res) {
      _this.actionMask.queryParserState.state = false;
      _this.actionMask.queryParserState.reply = true;

      if (_this.actionMask.replyParserState) {
        _this.emit('serialport:read', res.raw);
      }
    });
    this.runner.on('parameters', function (res) {
      _this.emit('serialport:read', res.raw);
    });
    this.runner.on('feedback', function (res) {
      _this.emit('serialport:read', res.raw);
    });
    this.runner.on('settings', function (res) {
      var setting = (0, _find2["default"])(_constants2.GRBL_SETTINGS, {
        setting: res.name
      });

      if (!res.message && setting) {
        // Grbl v1.1
        _this.emit('serialport:read', "".concat(res.name, "=").concat(res.value, " (").concat(setting.message, ", ").concat(setting.units, ")"));
      } else {
        // Grbl v0.9
        _this.emit('serialport:read', res.raw);
      }
    });
    this.runner.on('startup', function (res) {
      _this.emit('serialport:read', res.raw); // The startup message always prints upon startup, after a reset, or at program end.
      // Setting the initial state when Grbl has completed re-initializing all systems.


      _this.clearActionValues(); // Set ready flag to true when a startup message has arrived


      _this.ready = true;

      if (!_this.initialized) {
        _this.initialized = true; // Initialize controller

        _this.initController();
      }
    });
    this.runner.on('others', function (res) {
      _this.emit('serialport:read', res.raw);
    });

    var queryStatusReport = function queryStatusReport() {
      // Check the ready flag
      if (!_this.ready) {
        return;
      }

      var now = new Date().getTime(); // The status report query (?) is a realtime command, it does not consume the receive buffer.

      var lastQueryTime = _this.actionTime.queryStatusReport;

      if (lastQueryTime > 0) {
        var timespan = Math.abs(now - lastQueryTime);
        var toleranceTime = 5000; // 5 seconds
        // Check if it has not been updated for a long time

        if (timespan >= toleranceTime) {
          log.debug("Continue status report query: timespan=".concat(timespan, "ms"));
          _this.actionMask.queryStatusReport = false;
        }
      }

      if (_this.actionMask.queryStatusReport) {
        return;
      }

      if (_this.isOpen()) {
        _this.actionMask.queryStatusReport = true;
        _this.actionTime.queryStatusReport = now;

        _this.connection.write('?');
      }
    };

    var queryParserState = (0, _throttle2["default"])(function () {
      // Check the ready flag
      if (!_this.ready) {
        return;
      }

      var now = new Date().getTime(); // Do not force query parser state ($G) when running a G-code program,
      // it will consume 3 bytes from the receive buffer in each time period.
      // @see https://github.com/cncjs/cncjs/issues/176
      // @see https://github.com/cncjs/cncjs/issues/186

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE && _this.runner.isIdle()) {
        var lastQueryTime = _this.actionTime.queryParserState;

        if (lastQueryTime > 0) {
          var timespan = Math.abs(now - lastQueryTime);
          var toleranceTime = 10000; // 10 seconds
          // Check if it has not been updated for a long time

          if (timespan >= toleranceTime) {
            log.debug("Continue parser state query: timespan=".concat(timespan, "ms"));
            _this.actionMask.queryParserState.state = false;
            _this.actionMask.queryParserState.reply = false;
          }
        }
      }

      if (_this.actionMask.queryParserState.state || _this.actionMask.queryParserState.reply) {
        return;
      }

      if (_this.isOpen()) {
        _this.actionMask.queryParserState.state = true;
        _this.actionMask.queryParserState.reply = false;
        _this.actionTime.queryParserState = now;

        _this.connection.write('$G\n');
      }
    }, 500);
    this.queryTimer = setInterval(function () {
      if (_this.isClose()) {
        // Serial port is closed
        return;
      } // Feeder


      if (_this.feeder.peek()) {
        _this.emit('feeder:status', _this.feeder.toJSON());
      } // Sender


      if (_this.sender.peek()) {
        _this.emit('sender:status', _this.sender.toJSON());
      }

      var zeroOffset = (0, _isEqual2["default"])(_this.runner.getWorkPosition(_this.state), _this.runner.getWorkPosition(_this.runner.state)); // Grbl settings

      if (_this.settings !== _this.runner.settings) {
        _this.settings = _this.runner.settings;

        _this.emit('controller:settings', _constants2.GRBL, _this.settings);

        _this.emit('Grbl:settings', _this.settings); // Backward compatibility

      } // Grbl state


      if (_this.state !== _this.runner.state) {
        _this.state = _this.runner.state;

        _this.emit('controller:state', _constants2.GRBL, _this.state);

        _this.emit('Grbl:state', _this.state); // Backward compatibility

      } // Check the ready flag


      if (!_this.ready) {
        return;
      } // ? - Status Report


      queryStatusReport(); // $G - Parser State

      queryParserState(); // Check if the machine has stopped movement after completion

      if (_this.actionTime.senderFinishTime > 0) {
        var machineIdle = zeroOffset && _this.runner.isIdle();

        var now = new Date().getTime();
        var timespan = Math.abs(now - _this.actionTime.senderFinishTime);
        var toleranceTime = 500; // in milliseconds

        if (!machineIdle) {
          // Extend the sender finish time
          _this.actionTime.senderFinishTime = now;
        } else if (timespan > toleranceTime) {
          log.silly("Finished sending G-code: timespan=".concat(timespan));
          _this.actionTime.senderFinishTime = 0; // Stop workflow

          _this.command('gcode:stop');
        }
      }
    }, 250);
  }

  _createClass(GrblController, [{
    key: "initController",
    value: function () {
      var _initController = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // https://github.com/cncjs/cncjs/issues/206
                // $13=0 (report in mm)
                // $13=1 (report in inches)
                this.writeln('$$');
                _context.next = 3;
                return (0, _delay["default"])(50);

              case 3:
                this.event.trigger('controller:ready');

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initController() {
        return _initController.apply(this, arguments);
      }

      return initController;
    }()
  }, {
    key: "populateContext",
    value: function populateContext(context) {
      // Machine position
      var _this$runner$getMachi = this.runner.getMachinePosition(),
          mposx = _this$runner$getMachi.x,
          mposy = _this$runner$getMachi.y,
          mposz = _this$runner$getMachi.z,
          mposa = _this$runner$getMachi.a,
          mposb = _this$runner$getMachi.b,
          mposc = _this$runner$getMachi.c; // Work position


      var _this$runner$getWorkP = this.runner.getWorkPosition(),
          posx = _this$runner$getWorkP.x,
          posy = _this$runner$getWorkP.y,
          posz = _this$runner$getWorkP.z,
          posa = _this$runner$getWorkP.a,
          posb = _this$runner$getWorkP.b,
          posc = _this$runner$getWorkP.c; // Modal group


      var modal = this.runner.getModalGroup(); // Tool

      var tool = this.runner.getTool(); // G-code parameters

      var parameters = this.runner.getParameters();
      return Object.assign(context || {}, _objectSpread({
        // User-defined global variables
        global: this.sharedContext,
        // Bounding box
        xmin: Number(context.xmin) || 0,
        xmax: Number(context.xmax) || 0,
        ymin: Number(context.ymin) || 0,
        ymax: Number(context.ymax) || 0,
        zmin: Number(context.zmin) || 0,
        zmax: Number(context.zmax) || 0,
        // Machine position
        mposx: Number(mposx) || 0,
        mposy: Number(mposy) || 0,
        mposz: Number(mposz) || 0,
        mposa: Number(mposa) || 0,
        mposb: Number(mposb) || 0,
        mposc: Number(mposc) || 0,
        // Work position
        posx: Number(posx) || 0,
        posy: Number(posy) || 0,
        posz: Number(posz) || 0,
        posa: Number(posa) || 0,
        posb: Number(posb) || 0,
        posc: Number(posc) || 0,
        // Modal group
        modal: {
          motion: modal.motion,
          wcs: modal.wcs,
          plane: modal.plane,
          units: modal.units,
          distance: modal.distance,
          feedrate: modal.feedrate,
          program: modal.program,
          spindle: modal.spindle,
          // M7 and M8 may be active at the same time, but a modal group violation might occur when issuing M7 and M8 together on the same line. Using the new line character (\n) to separate lines can avoid this issue.
          coolant: (0, _ensureArray["default"])(modal.coolant).join('\n')
        },
        // Tool
        tool: Number(tool) || 0,
        // G-code parameters
        params: parameters
      }, _constants.GLOBAL_OBJECTS));
    }
  }, {
    key: "clearActionValues",
    value: function clearActionValues() {
      this.actionMask.queryParserState.state = false;
      this.actionMask.queryParserState.reply = false;
      this.actionMask.queryStatusReport = false;
      this.actionMask.replyParserState = false;
      this.actionMask.replyStatusReport = false;
      this.actionTime.queryParserState = 0;
      this.actionTime.queryStatusReport = 0;
      this.actionTime.senderFinishTime = 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.queryTimer) {
        clearInterval(this.queryTimer);
        this.queryTimer = null;
      }

      if (this.runner) {
        this.runner.removeAllListeners();
        this.runner = null;
      }

      this.sockets = {};

      if (this.connection) {
        this.connection = null;
      }

      if (this.event) {
        this.event = null;
      }

      if (this.feeder) {
        this.feeder = null;
      }

      if (this.sender) {
        this.sender = null;
      }

      if (this.workflow) {
        this.workflow = null;
      }
    }
  }, {
    key: "status",
    get: function get() {
      return {
        port: this.options.port,
        baudrate: this.options.baudrate,
        rtscts: this.options.rtscts,
        sockets: Object.keys(this.sockets),
        ready: this.ready,
        controller: {
          type: this.type,
          settings: this.settings,
          state: this.state
        },
        feeder: this.feeder.toJSON(),
        sender: this.sender.toJSON(),
        workflow: {
          state: this.workflow.state
        }
      };
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;
      var _this$options = this.options,
          port = _this$options.port,
          baudrate = _this$options.baudrate; // Assertion check

      if (this.isOpen()) {
        log.error("Cannot open serial port \"".concat(port, "\""));
        return;
      }

      this.connection.on('data', this.connectionEventListener.data);
      this.connection.on('close', this.connectionEventListener.close);
      this.connection.on('error', this.connectionEventListener.error);
      this.connection.open(function (err) {
        if (err) {
          log.error("Error opening serial port \"".concat(port, "\":"), err);

          _this2.emit('serialport:error', {
            err: err,
            port: port
          });

          callback(err); // notify error

          return;
        }

        _this2.emit('serialport:open', {
          port: port,
          baudrate: baudrate,
          controllerType: _this2.type,
          inuse: true
        }); // Emit a change event to all connected sockets


        if (_this2.engine.io) {
          _this2.engine.io.emit('serialport:change', {
            port: port,
            inuse: true
          });
        }

        callback(); // register controller

        log.debug("Connected to serial port \"".concat(port, "\""));

        _this2.workflow.stop(); // Clear action values


        _this2.clearActionValues();

        if (_this2.sender.state.gcode) {
          // Unload G-code
          _this2.command('unload');
        }
      });
    }
  }, {
    key: "close",
    value: function close(callback) {
      var port = this.options.port; // Assertion check

      if (!this.connection) {
        var err = "Serial port \"".concat(port, "\" is not available");
        callback(new Error(err));
        return;
      } // Stop status query


      this.ready = false; // Clear initialized flag

      this.initialized = false;
      this.emit('serialport:close', {
        port: port,
        inuse: false
      }); // Emit a change event to all connected sockets

      if (this.engine.io) {
        this.engine.io.emit('serialport:change', {
          port: port,
          inuse: false
        });
      }

      if (this.isClose()) {
        callback(null);
        return;
      }

      this.connection.removeAllListeners();
      this.connection.close(callback);
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.connection && this.connection.isOpen;
    }
  }, {
    key: "isClose",
    value: function isClose() {
      return !this.isOpen();
    }
  }, {
    key: "addConnection",
    value: function addConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Add socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = socket; //
      // Send data to newly connected client
      //

      if (this.isOpen()) {
        socket.emit('serialport:open', {
          port: this.options.port,
          baudrate: this.options.baudrate,
          controllerType: this.type,
          inuse: true
        });
      }

      if (!(0, _isEmpty2["default"])(this.settings)) {
        // controller settings
        socket.emit('controller:settings', _constants2.GRBL, this.settings);
        socket.emit('Grbl:settings', this.settings); // Backward compatibility
      }

      if (!(0, _isEmpty2["default"])(this.state)) {
        // controller state
        socket.emit('controller:state', _constants2.GRBL, this.state);
        socket.emit('Grbl:state', this.state); // Backward compatibility
      }

      if (this.feeder) {
        // feeder status
        socket.emit('feeder:status', this.feeder.toJSON());
      }

      if (this.sender) {
        // sender status
        socket.emit('sender:status', this.sender.toJSON());
        var _this$sender$state4 = this.sender.state,
            name = _this$sender$state4.name,
            gcode = _this$sender$state4.gcode,
            context = _this$sender$state4.context;

        if (gcode) {
          socket.emit('gcode:load', name, gcode, context);
        }
      }

      if (this.workflow) {
        // workflow state
        socket.emit('workflow:state', this.workflow.state);
      }
    }
  }, {
    key: "removeConnection",
    value: function removeConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Remove socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = undefined;
      delete this.sockets[socket.id];
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this3 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      Object.keys(this.sockets).forEach(function (id) {
        var socket = _this3.sockets[id];
        socket.emit.apply(socket, [eventName].concat(args));
      });
    }
  }, {
    key: "command",
    value: function command(cmd) {
      var _this4 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var handler = {
        'gcode:load': function gcodeLoad() {
          var name = args[0],
              gcode = args[1],
              _args$ = args[2],
              context = _args$ === void 0 ? {} : _args$,
              _args$2 = args[3],
              callback = _args$2 === void 0 ? noop : _args$2;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          } // G4 P0 or P with a very small value will empty the planner queue and then
          // respond with an ok when the dwell is complete. At that instant, there will
          // be no queued motions, as long as no more commands were sent after the G4.
          // This is the fastest way to do it without having to check the status reports.


          var dwell = '%wait ; Wait for the planner to empty';

          var ok = _this4.sender.load(name, gcode + '\n' + dwell, context);

          if (!ok) {
            callback(new Error("Invalid G-code: name=".concat(name)));
            return;
          }

          _this4.emit('gcode:load', name, gcode, context);

          _this4.event.trigger('gcode:load');

          log.debug("Load G-code: name=\"".concat(_this4.sender.state.name, "\", size=").concat(_this4.sender.state.gcode.length, ", total=").concat(_this4.sender.state.total));

          _this4.workflow.stop();

          callback(null, _this4.sender.toJSON());
        },
        'gcode:unload': function gcodeUnload() {
          _this4.workflow.stop(); // Sender


          _this4.sender.unload();

          _this4.emit('gcode:unload');

          _this4.event.trigger('gcode:unload');
        },
        'start': function start() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:start');
        },
        'gcode:start': function gcodeStart() {
          _this4.event.trigger('gcode:start');

          _this4.workflow.start(); // Feeder


          _this4.feeder.reset(); // Sender


          _this4.sender.next();
        },
        'stop': function stop() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command.apply(_this4, ['gcode:stop'].concat(args));
        },
        // @param {object} options The options object.
        // @param {boolean} [options.force] Whether to force stop a G-code program. Defaults to false.
        'gcode:stop': function () {
          var _gcodeStop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var options, _options2, _options2$force, force, activeState;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _this4.event.trigger('gcode:stop');

                    _this4.workflow.stop();

                    options = args[0];
                    _options2 = _objectSpread({}, options), _options2$force = _options2.force, force = _options2$force === void 0 ? false : _options2$force;

                    if (!force) {
                      _context2.next = 11;
                      break;
                    }

                    activeState = (0, _get2["default"])(_this4.state, 'status.activeState', '');

                    if (activeState === _constants2.GRBL_ACTIVE_STATE_RUN) {
                      _this4.write('!'); // hold

                    }

                    _context2.next = 9;
                    return (0, _delay["default"])(500);

                  case 9:
                    // delay 500ms
                    activeState = (0, _get2["default"])(_this4.state, 'status.activeState', '');

                    if (activeState === _constants2.GRBL_ACTIVE_STATE_HOLD) {
                      _this4.write('\x18'); // ^x

                    }

                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function gcodeStop() {
            return _gcodeStop.apply(this, arguments);
          }

          return gcodeStop;
        }(),
        'pause': function pause() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:pause');
        },
        'gcode:pause': function gcodePause() {
          _this4.event.trigger('gcode:pause');

          _this4.workflow.pause();

          _this4.write('!');
        },
        'resume': function resume() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this4.command('gcode:resume');
        },
        'gcode:resume': function gcodeResume() {
          _this4.event.trigger('gcode:resume');

          _this4.write('~');

          _this4.workflow.resume();
        },
        'feeder:feed': function feederFeed() {
          var commands = args[0],
              _args$3 = args[1],
              context = _args$3 === void 0 ? {} : _args$3;

          _this4.command('gcode', commands, context);
        },
        'feeder:start': function feederStart() {
          if (_this4.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
            return;
          }

          _this4.write('~');

          _this4.feeder.unhold();

          _this4.feeder.next();
        },
        'feeder:stop': function feederStop() {
          _this4.feeder.reset();
        },
        'feedhold': function feedhold() {
          _this4.event.trigger('feedhold');

          _this4.write('!');
        },
        'cyclestart': function cyclestart() {
          _this4.event.trigger('cyclestart');

          _this4.write('~');
        },
        'statusreport': function statusreport() {
          _this4.write('?');
        },
        'homing': function homing() {
          _this4.event.trigger('homing');

          _this4.writeln('$H');
        },
        'sleep': function sleep() {
          _this4.event.trigger('sleep');

          _this4.writeln('$SLP');
        },
        'unlock': function unlock() {
          _this4.writeln('$X');
        },
        'reset': function reset() {
          _this4.workflow.stop();

          _this4.feeder.reset();

          _this4.write('\x18'); // ^x

        },
        // Feed Overrides
        // @param {number} value The amount of percentage increase or decrease.
        //   0: Set 100% of programmed rate.
        //  10: Increase 10%
        // -10: Decrease 10%
        //   1: Increase 1%
        //  -1: Decrease 1%
        'feedOverride': function feedOverride() {
          var value = args[0];

          if (value === 0) {
            _this4.write('\x90');
          } else if (value === 10) {
            _this4.write('\x91');
          } else if (value === -10) {
            _this4.write('\x92');
          } else if (value === 1) {
            _this4.write('\x93');
          } else if (value === -1) {
            _this4.write('\x94');
          }
        },
        // Spindle Speed Overrides
        // @param {number} value The amount of percentage increase or decrease.
        //   0: Set 100% of programmed spindle speed
        //  10: Increase 10%
        // -10: Decrease 10%
        //   1: Increase 1%
        //  -1: Decrease 1%
        'spindleOverride': function spindleOverride() {
          var value = args[0];

          if (value === 0) {
            _this4.write('\x99');
          } else if (value === 10) {
            _this4.write('\x9a');
          } else if (value === -10) {
            _this4.write('\x9b');
          } else if (value === 1) {
            _this4.write('\x9c');
          } else if (value === -1) {
            _this4.write('\x9d');
          }
        },
        // Rapid Overrides
        // @param {number} value A percentage value of 25, 50, or 100. A value of zero will reset to 100%.
        // 100: Set to 100% full rapid rate.
        //  50: Set to 50% of rapid rate.
        //  25: Set to 25% of rapid rate.
        'rapidOverride': function rapidOverride() {
          var value = args[0];

          if (value === 0 || value === 100) {
            _this4.write('\x95');
          } else if (value === 50) {
            _this4.write('\x96');
          } else if (value === 25) {
            _this4.write('\x97');
          }
        },
        'lasertest:on': function lasertestOn() {
          var _args$4 = args[0],
              power = _args$4 === void 0 ? 0 : _args$4,
              _args$5 = args[1],
              duration = _args$5 === void 0 ? 0 : _args$5,
              _args$6 = args[2],
              maxS = _args$6 === void 0 ? 1000 : _args$6;
          var commands = [// https://github.com/gnea/grbl/wiki/Grbl-v1.1-Laser-Mode
          // The laser will only turn on when Grbl is in a G1, G2, or G3 motion mode.
          'G1F1', 'M3S' + (0, _ensurePositiveNumber["default"])(maxS * (power / 100))];

          if (duration > 0) {
            commands.push('G4P' + (0, _ensurePositiveNumber["default"])(duration / 1000));
            commands.push('M5S0');
          }

          _this4.command('gcode', commands);
        },
        'lasertest:off': function lasertestOff() {
          var commands = ['M5S0'];

          _this4.command('gcode', commands);
        },
        'gcode': function gcode() {
          var commands = args[0],
              context = args[1];
          var data = (0, _ensureArray["default"])(commands).join('\n').split(/\r?\n/).filter(function (line) {
            if (typeof line !== 'string') {
              return false;
            }

            return line.trim().length > 0;
          });

          _this4.feeder.feed(data, context);

          if (!_this4.feeder.isPending()) {
            _this4.feeder.next();
          }
        },
        'macro:run': function macroRun() {
          var id = args[0],
              _args$7 = args[1],
              context = _args$7 === void 0 ? {} : _args$7,
              _args$8 = args[2],
              callback = _args$8 === void 0 ? noop : _args$8;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this4.event.trigger('macro:run');

          _this4.command('gcode', macro.content, context);

          callback(null);
        },
        'macro:load': function macroLoad() {
          var id = args[0],
              _args$9 = args[1],
              context = _args$9 === void 0 ? {} : _args$9,
              _args$10 = args[2],
              callback = _args$10 === void 0 ? noop : _args$10;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this4.event.trigger('macro:load');

          _this4.command('gcode:load', macro.name, macro.content, context, callback);
        },
        'watchdir:load': function watchdirLoad() {
          var file = args[0],
              _args$11 = args[1],
              callback = _args$11 === void 0 ? noop : _args$11;
          var context = {}; // empty context

          _monitor["default"].readFile(file, function (err, data) {
            if (err) {
              callback(err);
              return;
            }

            _this4.command('gcode:load', file, data, context, callback);
          });
        }
      }[cmd];

      if (!handler) {
        log.error("Unknown command: ".concat(cmd));
        return;
      }

      handler();
    }
  }, {
    key: "write",
    value: function write(data, context) {
      // Assertion check
      if (this.isClose()) {
        log.error("Serial port \"".concat(this.options.port, "\" is not accessible"));
        return;
      }

      var cmd = data.trim();
      this.actionMask.replyStatusReport = cmd === '?' || this.actionMask.replyStatusReport;
      this.actionMask.replyParserState = cmd === '$G' || this.actionMask.replyParserState;
      this.emit('serialport:write', data, _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_CLIENT
      }));
      this.connection.write(data);
      log.silly("> ".concat(data));
    }
  }, {
    key: "writeln",
    value: function writeln(data, context) {
      if ((0, _includes2["default"])(_constants2.GRBL_REALTIME_COMMANDS, data)) {
        this.write(data, context);
      } else {
        this.write(data + '\n', context);
      }
    }
  }]);

  return GrblController;
}();

var _default = GrblController;
exports["default"] = _default;