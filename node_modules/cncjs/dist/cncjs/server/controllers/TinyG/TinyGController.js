"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _pickBy2 = _interopRequireDefault(require("lodash/pickBy"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _find2 = _interopRequireDefault(require("lodash/find"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _ensureArray = _interopRequireDefault(require("ensure-array"));

var parser = _interopRequireWildcard(require("gcode-parser"));

var _SerialConnection = _interopRequireDefault(require("../../lib/SerialConnection"));

var _EventTrigger = _interopRequireDefault(require("../../lib/EventTrigger"));

var _Feeder = _interopRequireDefault(require("../../lib/Feeder"));

var _Sender = _interopRequireWildcard(require("../../lib/Sender"));

var _Workflow = _interopRequireWildcard(require("../../lib/Workflow"));

var _delay = _interopRequireDefault(require("../../lib/delay"));

var _ensurePositiveNumber = _interopRequireDefault(require("../../lib/ensure-positive-number"));

var _ensureType = require("../../lib/ensure-type");

var _evaluateAssignmentExpression = _interopRequireDefault(require("../../lib/evaluate-assignment-expression"));

var _logger = _interopRequireDefault(require("../../lib/logger"));

var _translateExpression = _interopRequireDefault(require("../../lib/translate-expression"));

var _configstore = _interopRequireDefault(require("../../services/configstore"));

var _monitor = _interopRequireDefault(require("../../services/monitor"));

var _taskrunner = _interopRequireDefault(require("../../services/taskrunner"));

var _store = _interopRequireDefault(require("../../store"));

var _constants = require("../constants");

var _TinyGRunner = _interopRequireDefault(require("./TinyGRunner"));

var _constants2 = require("./constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SENDER_STATUS_NONE = 'none';
var SENDER_STATUS_NEXT = 'next';
var SENDER_STATUS_ACK = 'ack'; // % commands

var WAIT = '%wait';
var log = (0, _logger["default"])('controller:TinyG');

var noop = function noop() {};

var TinyGController = /*#__PURE__*/function () {
  // CNCEngine
  // Sockets
  // Connection
  // TinyG
  // Event Trigger
  // Feeder
  // Sender
  // Shared context
  // Workflow
  function TinyGController(engine, options) {
    var _this = this;

    _classCallCheck(this, TinyGController);

    _defineProperty(this, "type", _constants2.TINYG);

    _defineProperty(this, "engine", null);

    _defineProperty(this, "sockets", {});

    _defineProperty(this, "connection", null);

    _defineProperty(this, "connectionEventListener", {
      data: function data(_data) {
        log.silly("< ".concat(_data));

        _this.runner.parse('' + _data);
      },
      close: function close(err) {
        _this.ready = false;

        if (err) {
          log.warn("Disconnected from serial port \"".concat(_this.options.port, "\":"), err);
        }

        _this.close(function (err) {
          // Remove controller from store
          var port = _this.options.port;

          _store["default"].unset("controllers[".concat(JSON.stringify(port), "]")); // Destroy controller


          _this.destroy();
        });
      },
      error: function error(err) {
        _this.ready = false;

        if (err) {
          log.error("Unexpected error while reading/writing serial port \"".concat(_this.options.port, "\":"), err);
        }
      }
    });

    _defineProperty(this, "tinyg", null);

    _defineProperty(this, "ready", false);

    _defineProperty(this, "state", {});

    _defineProperty(this, "settings", {});

    _defineProperty(this, "sr", {
      stat: true,
      // machine state
      line: true,
      // runtime line number
      vel: true,
      // current velocity
      feed: true,
      // feed rate
      unit: true,
      // units mode
      coor: true,
      // coordinate system
      momo: true,
      // motion mode
      plan: true,
      // plane select
      path: true,
      // path control mode
      dist: true,
      // distance mode
      admo: true,
      // arc distance mode
      frmo: true,
      // feed rate mode
      tool: true,
      // active tool
      posx: true,
      posy: true,
      posz: true,
      posa: true,
      posb: true,
      posc: true,
      mpox: true,
      mpoy: true,
      mpoz: true,
      mpoa: true,
      mpob: true,
      mpoc: true,
      spe: true,
      // [edge-082.10] Spindle enable (removed in edge-101.03)
      spd: true,
      // [edge-082.10] Spindle direction (removed in edge-101.03)
      spc: true,
      // [edge-101.03] Spindle control
      sps: true,
      // [edge-082.10] Spindle speed
      com: true,
      // [edge-082.10] Mist coolant
      cof: true // [edge-082.10] Flood coolant

    });

    _defineProperty(this, "timer", {
      query: null,
      energizeMotors: null
    });

    _defineProperty(this, "energizeMotorsTimer", null);

    _defineProperty(this, "blocked", false);

    _defineProperty(this, "senderStatus", SENDER_STATUS_NONE);

    _defineProperty(this, "actionTime", {
      energizeMotors: 0,
      senderFinishTime: 0
    });

    _defineProperty(this, "event", null);

    _defineProperty(this, "feeder", null);

    _defineProperty(this, "sender", null);

    _defineProperty(this, "sharedContext", {});

    _defineProperty(this, "workflow", null);

    if (!engine) {
      throw new Error('engine must be specified');
    }

    this.engine = engine;

    var _options = _objectSpread({}, options),
        _port = _options.port,
        baudrate = _options.baudrate,
        rtscts = _options.rtscts;

    this.options = _objectSpread(_objectSpread({}, this.options), {}, {
      port: _port,
      baudrate: baudrate,
      rtscts: rtscts
    }); // Connection

    this.connection = new _SerialConnection["default"]({
      path: _port,
      baudRate: baudrate,
      rtscts: rtscts,
      writeFilter: function writeFilter(data) {
        return data;
      }
    }); // Event Trigger

    this.event = new _EventTrigger["default"](function (event, trigger, commands) {
      log.debug("EventTrigger: event=\"".concat(event, "\", trigger=\"").concat(trigger, "\", commands=\"").concat(commands, "\""));

      if (trigger === 'system') {
        _taskrunner["default"].run(commands);
      } else {
        _this.command('gcode', commands);
      }
    }); // Feeder

    this.feeder = new _Feeder["default"]({
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        // @see https://github.com/synthetos/g2/wiki/JSON-Active-Comments
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug('Wait for the planner to empty');

            _this.feeder.hold({
              data: WAIT
            }); // Hold reason


            return 'G4 P0.5'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words);
        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug('M0 Program Pause');

            _this.feeder.hold({
              data: 'M0'
            }); // Hold reason

          } else if (programMode === 'M1') {
            log.debug('M1 Program Pause');

            _this.feeder.hold({
              data: 'M1'
            }); // Hold reason

          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug('M6 Tool Change');

          _this.feeder.hold({
            data: 'M6'
          }); // Hold reason

        }

        return line;
      }
    });
    this.feeder.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.runner.isAlarm()) {
        _this.feeder.reset();

        log.warn('Stopped sending G-code commands in Alarm mode');
        return;
      }

      line = String(line).trim();

      if (line.length === 0) {
        return;
      }

      _this.emit('serialport:write', line + '\n', _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_FEEDER
      }));

      _this.connection.write(line + '\n');

      log.silly("> ".concat(line));
    });
    this.feeder.on('hold', noop);
    this.feeder.on('unhold', noop); // Sender

    this.sender = new _Sender["default"](_Sender.SP_TYPE_SEND_RESPONSE, {
      dataFilter: function dataFilter(line, context) {
        // Remove comments that start with a semicolon `;`
        // @see https://github.com/synthetos/g2/wiki/JSON-Active-Comments
        line = line.replace(/\s*;.*/g, '').trim();
        context = _this.populateContext(context);
        var _this$sender$state = _this.sender.state,
            sent = _this$sender$state.sent,
            received = _this$sender$state.received;

        if (line[0] === '%') {
          // %wait
          if (line === WAIT) {
            log.debug("Wait for the planner to empty: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.sender.hold({
              data: WAIT
            }); // Hold reason


            return 'G4 P0.5'; // dwell
          } // Expression
          // %_x=posx,_y=posy,_z=posz


          (0, _evaluateAssignmentExpression["default"])(line.slice(1), context);
          return '';
        } // line="G0 X[posx - 8] Y[ymax]"
        // > "G0 X2 Y50"


        line = (0, _translateExpression["default"])(line, context);
        var data = parser.parseLine(line, {
          flatten: true
        });
        var words = (0, _ensureArray["default"])(data.words);
        {
          // Program Mode: M0, M1
          var programMode = (0, _intersection2["default"])(words, ['M0', 'M1'])[0];

          if (programMode === 'M0') {
            log.debug("M0 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M0'
            });
          } else if (programMode === 'M1') {
            log.debug("M1 Program Pause: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

            _this.workflow.pause({
              data: 'M1'
            });
          }
        } // M6 Tool Change

        if ((0, _includes2["default"])(words, 'M6')) {
          log.debug("M6 Tool Change: line=".concat(sent + 1, ", sent=").concat(sent, ", received=").concat(received));

          _this.workflow.pause({
            data: 'M6'
          });
        }

        return line;
      }
    });
    this.sender.on('data', function () {
      var line = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.isClose()) {
        log.error("Serial port \"".concat(_this.options.port, "\" is not accessible"));
        return;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE) {
        log.error("Unexpected workflow state: ".concat(_this.workflow.state));
        return;
      } // Remove blanks to reduce the amount of bandwidth


      line = String(line).replace(/\s+/g, '');

      if (line.length === 0) {
        log.warn("Expected non-empty line: N=".concat(_this.sender.state.sent));
        return;
      } // Replace line numbers with the number of lines sent


      var n = _this.sender.state.sent;
      line = ('' + line).replace(/^N[0-9]*/, '');
      line = 'N' + n + line;

      _this.connection.write(line + '\n');

      log.silly("data: n=".concat(n, ", line=\"").concat(line, "\""));
    });
    this.sender.on('hold', noop);
    this.sender.on('unhold', noop);
    this.sender.on('start', function (startTime) {
      _this.actionTime.senderFinishTime = 0;
    });
    this.sender.on('end', function (finishTime) {
      _this.actionTime.senderFinishTime = finishTime;
    }); // Workflow

    this.workflow = new _Workflow["default"]();
    this.workflow.on('start', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.blocked = false;
      _this.senderStatus = SENDER_STATUS_NONE;

      _this.sender.rewind();
    });
    this.workflow.on('stop', function () {
      _this.emit('workflow:state', _this.workflow.state);

      _this.blocked = false;
      _this.senderStatus = SENDER_STATUS_NONE;

      _this.sender.rewind();
    });
    this.workflow.on('pause', function () {
      _this.emit('workflow:state', _this.workflow.state);

      if (arguments.length > 0) {
        var reason = _objectSpread({}, arguments.length <= 0 ? undefined : arguments[0]);

        _this.sender.hold(reason); // Hold reason

      } else {
        _this.sender.hold();
      }
    });
    this.workflow.on('resume', function () {
      _this.emit('workflow:state', _this.workflow.state); // Reset feeder prior to resume program execution


      _this.feeder.reset(); // Resume program execution


      _this.sender.unhold();

      _this.sender.next();
    }); // TinyG

    this.runner = new _TinyGRunner["default"]();
    this.runner.on('raw', function (res) {
      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE) {
        _this.emit('serialport:read', res.raw);
      }
    }); // https://github.com/synthetos/g2/wiki/g2core-Communications

    this.runner.on('r', function (r) {
      //
      // Ignore unrecognized commands
      //
      if (r && r.spe === null) {
        _this.sr.spe = false; // No spindle enable
      }

      if (r && r.spd === null) {
        _this.sr.spd = false; // No spindle direction
      }

      if (r && r.spc === null) {
        _this.sr.spc = false; // No spindle control
      }

      if (r && r.sps === null) {
        _this.sr.sps = false; // No spindle speed
      }

      if (r && r.com === null) {
        _this.sr.com = false; // No mist coolant
      }

      if (r && r.cof === null) {
        _this.sr.cof = false; // No flood coolant
      }

      var _this$sender$state2 = _this.sender.state,
          hold = _this$sender$state2.hold,
          sent = _this$sender$state2.sent,
          received = _this$sender$state2.received;

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        var n = (0, _get2["default"])(r, 'r.n') || (0, _get2["default"])(r, 'n');

        if (n !== sent) {
          log.warn("Expression: n (".concat(n, ") === sent (").concat(sent, ")"));
        }

        log.silly("ack: n=".concat(n, ", blocked=").concat(_this.blocked, ", hold=").concat(hold, ", sent=").concat(sent, ", received=").concat(received));
        _this.senderStatus = SENDER_STATUS_ACK;

        if (!_this.blocked) {
          _this.sender.ack();

          _this.sender.next();

          _this.senderStatus = SENDER_STATUS_NEXT;
        }

        return;
      } // The execution can be manually paused or issue a M0 command to pause
      // * M0, M1 Program Pause
      // * M2, M30 Program End
      // * M6 Tool Change


      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_PAUSED && received < sent) {
        if (!hold) {
          log.error('The sender does not hold off during the paused state');
        }

        if (received + 1 >= sent) {
          log.debug("Stop sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received + 1));
        }

        var _n = (0, _get2["default"])(r, 'r.n') || (0, _get2["default"])(r, 'n');

        if (_n !== sent) {
          log.warn("Expression: n (".concat(_n, ") === sent (").concat(sent, ")"));
        }

        log.silly("ack: n=".concat(_n, ", blocked=").concat(_this.blocked, ", hold=").concat(hold, ", sent=").concat(sent, ", received=").concat(received));
        _this.senderStatus = SENDER_STATUS_ACK;

        _this.sender.ack();

        _this.sender.next();

        _this.senderStatus = SENDER_STATUS_NEXT;
        return;
      }

      console.assert(_this.workflow.state !== _Workflow.WORKFLOW_STATE_RUNNING, "workflow.state !== '".concat(_Workflow.WORKFLOW_STATE_RUNNING, "'")); // Feeder

      _this.feeder.next();
    });
    this.runner.on('qr', function (_ref) {
      var qr = _ref.qr;
      log.silly("planner queue: qr=".concat(qr, ", lw=").concat(_constants2.TINYG_PLANNER_BUFFER_LOW_WATER_MARK, ", hw=").concat(_constants2.TINYG_PLANNER_BUFFER_HIGH_WATER_MARK));
      _this.state.qr = qr;

      if (qr <= _constants2.TINYG_PLANNER_BUFFER_LOW_WATER_MARK) {
        _this.blocked = true;
        return;
      }

      if (qr >= _constants2.TINYG_PLANNER_BUFFER_HIGH_WATER_MARK) {
        _this.blocked = false;
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
        var _this$sender$state3 = _this.sender.state,
            hold = _this$sender$state3.hold,
            sent = _this$sender$state3.sent,
            received = _this$sender$state3.received;
        log.silly("sender: status=".concat(_this.senderStatus, ", hold=").concat(hold, ", sent=").concat(sent, ", received=").concat(received));

        if (_this.senderStatus === SENDER_STATUS_NEXT) {
          if (hold && received >= sent && qr >= _this.runner.plannerBufferPoolSize) {
            log.debug("Continue sending G-code: hold=".concat(hold, ", sent=").concat(sent, ", received=").concat(received, ", qr=").concat(qr));

            _this.sender.unhold();

            _this.sender.next();

            _this.senderStatus = SENDER_STATUS_NEXT;
          }
        } else if (_this.senderStatus === SENDER_STATUS_ACK) {
          _this.sender.ack();

          _this.sender.next();

          _this.senderStatus = SENDER_STATUS_NEXT;
        }

        return;
      } // The execution is manually paused


      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_PAUSED && _this.senderStatus === SENDER_STATUS_ACK) {
        var _this$sender$state4 = _this.sender.state,
            _hold = _this$sender$state4.hold,
            _sent = _this$sender$state4.sent,
            _received = _this$sender$state4.received;
        log.silly("sender: status=".concat(_this.senderStatus, ", hold=").concat(_hold, ", sent=").concat(_sent, ", received=").concat(_received));

        if (_received >= _sent) {
          log.error("Expression: received (".concat(_received, ") < sent (").concat(_sent, ")"));
        }

        if (!_hold) {
          log.error('The sender does not hold off during the paused state');
        }

        if (_received + 1 >= _sent) {
          log.debug("Stop sending G-code: hold=".concat(_hold, ", sent=").concat(_sent, ", received=").concat(_received + 1));
        }

        _this.sender.ack();

        _this.sender.next();

        _this.senderStatus = SENDER_STATUS_NEXT;
        return;
      }

      console.assert(_this.workflow.state !== _Workflow.WORKFLOW_STATE_RUNNING, "workflow.state !== '".concat(_Workflow.WORKFLOW_STATE_RUNNING, "'")); // Feeder

      if (_this.feeder.state.hold) {
        var _this$feeder$state$ho = _objectSpread({}, _this.feeder.state.holdReason),
            data = _this$feeder$state$ho.data;

        if (data === WAIT && qr >= _this.runner.plannerBufferPoolSize) {
          _this.feeder.unhold();
        }
      }

      _this.feeder.next();
    });
    this.runner.on('sr', function (sr) {});
    this.runner.on('fb', function (fb) {});
    this.runner.on('hp', function (hp) {});
    this.runner.on('f', function (f) {
      // https://github.com/synthetos/g2/wiki/Status-Codes
      var statusCode = f[1] || 0;

      if (statusCode !== 0) {
        var code = Number(statusCode);
        var err = (0, _find2["default"])(_constants2.TINYG_STATUS_CODES, {
          code: code
        }) || {};

        if (_this.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
          var ignoreErrors = _configstore["default"].get('state.controller.exception.ignoreErrors');

          var pauseError = !ignoreErrors;
          var _this$sender$state5 = _this.sender.state,
              lines = _this$sender$state5.lines,
              received = _this$sender$state5.received;
          var line = lines[received - 1] || '';

          _this.emit('serialport:read', "> ".concat(line));

          _this.emit('serialport:read', JSON.stringify({
            err: {
              code: code,
              msg: err.msg,
              line: received,
              data: line.trim()
            }
          }));

          log.error('Error:', {
            code: code,
            msg: err.msg,
            line: received,
            data: line.trim()
          });

          if (pauseError) {
            _this.workflow.pause({
              err: err.msg
            });
          }

          return;
        }

        _this.emit('serialport:read', JSON.stringify({
          err: {
            code: code,
            msg: err.msg
          }
        }));
      }

      if (_this.workflow.state === _Workflow.WORKFLOW_STATE_IDLE) {
        _this.feeder.next();
      }
    }); // Query Timer

    this.timer.query = setInterval(function () {
      if (_this.isClose()) {
        // Serial port is closed
        return;
      } // Feeder


      if (_this.feeder.peek()) {
        _this.emit('feeder:status', _this.feeder.toJSON());
      } // Sender


      if (_this.sender.peek()) {
        _this.emit('sender:status', _this.sender.toJSON());
      }

      var zeroOffset = (0, _isEqual2["default"])(_this.runner.getWorkPosition(_this.state), _this.runner.getWorkPosition(_this.runner.state)); // TinyG settings

      if (_this.settings !== _this.runner.settings) {
        _this.settings = _this.runner.settings;

        _this.emit('controller:settings', _constants2.TINYG, _this.settings);

        _this.emit('TinyG:settings', _this.settings); // Backward compatibility

      } // TinyG state


      if (_this.state !== _this.runner.state) {
        _this.state = _this.runner.state;

        _this.emit('controller:state', _constants2.TINYG, _this.state);

        _this.emit('TinyG:state', _this.state); // Backward compatibility

      } // Check the ready flag


      if (!_this.ready) {
        return;
      } // Check if the machine has stopped movement after completion


      if (_this.actionTime.senderFinishTime > 0) {
        var machineIdle = zeroOffset && _this.runner.isIdle();

        var now = new Date().getTime();
        var timespan = Math.abs(now - _this.actionTime.senderFinishTime);
        var toleranceTime = 500; // in milliseconds

        if (!machineIdle) {
          // Extend the sender finish time if the controller state is not idle
          _this.actionTime.senderFinishTime = now;
        } else if (timespan > toleranceTime) {
          log.silly("Finished sending G-code: timespan=".concat(timespan));
          _this.actionTime.senderFinishTime = 0; // Stop workflow

          _this.command('gcode:stop');
        }
      }
    }, 250);
  } // https://github.com/synthetos/TinyG/wiki/TinyG-Configuration-for-Firmware-Version-0.97


  _createClass(TinyGController, [{
    key: "initController",
    value: function () {
      var _initController = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        var send, relaxedJSON;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                send = function send() {
                  var cmd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

                  if (_this2.isClose()) {
                    // Serial port is closed
                    return;
                  }

                  cmd = String(cmd);

                  if (cmd.length >= _constants2.TINYG_SERIAL_BUFFER_LIMIT) {
                    log.error("Exceeded serial buffer limit (".concat(_constants2.TINYG_SERIAL_BUFFER_LIMIT, "): cmd=").concat(cmd));
                    return;
                  }

                  log.silly("init: ".concat(cmd, " ").concat(cmd.length));

                  _this2.command('gcode', cmd);
                };

                relaxedJSON = function relaxedJSON(json) {
                  if (_typeof(json) === 'object') {
                    json = JSON.stringify(json);
                  }

                  return json.replace(/"/g, '').replace(/true/g, 't');
                }; // Enable JSON mode
                // 0=text mode, 1=JSON mode


                send('{ej:1}'); // JSON verbosity
                // 0=silent, 1=footer, 2=messages, 3=configs, 4=linenum, 5=verbose

                send('{jv:4}'); // Queue report verbosity
                // 0=off, 1=filtered, 2=verbose

                send('{qv:1}'); // Status report verbosity
                // 0=off, 1=filtered, 2=verbose

                send('{sv:1}'); // Status report interval
                // in milliseconds (50ms minimum interval)

                send('{si:100}'); // Check whether the spindle and coolant commands are supported

                _context.next = 9;
                return (0, _delay["default"])(100);

              case 9:
                send('{spe:n}');
                _context.next = 12;
                return (0, _delay["default"])(100);

              case 12:
                send('{spd:n}');
                _context.next = 15;
                return (0, _delay["default"])(100);

              case 15:
                send('{spc:n}');
                _context.next = 18;
                return (0, _delay["default"])(100);

              case 18:
                send('{sps:n}');
                _context.next = 21;
                return (0, _delay["default"])(100);

              case 21:
                send('{com:n}');
                _context.next = 24;
                return (0, _delay["default"])(100);

              case 24:
                send('{cof:n}'); // Wait for a certain amount of time before setting status report fields

                _context.next = 27;
                return (0, _delay["default"])(200);

              case 27:
                // Settings Status Report Fields
                // https://github.com/synthetos/TinyG/wiki/TinyG-Status-Reports#setting-status-report-fields
                // Note: The JSON string is minified to make sure the length won't exceed the serial buffer limit
                send(relaxedJSON({
                  // Returns an object composed of the picked properties
                  sr: (0, _pickBy2["default"])(this.sr, function (value, key) {
                    return !!value;
                  })
                })); // Request system settings

                send('{sys:n}'); // Request motor timeout

                send('{mt:n}'); // Request motor states

                send('{pwr:n}'); // Request queue report

                send('{qr:n}'); // Request status report

                send('{sr:n}');
                _context.next = 35;
                return (0, _delay["default"])(50);

              case 35:
                this.event.trigger('controller:ready');

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initController() {
        return _initController.apply(this, arguments);
      }

      return initController;
    }()
  }, {
    key: "populateContext",
    value: function populateContext(context) {
      // Machine position
      var _this$runner$getMachi = this.runner.getMachinePosition(),
          mposx = _this$runner$getMachi.x,
          mposy = _this$runner$getMachi.y,
          mposz = _this$runner$getMachi.z,
          mposa = _this$runner$getMachi.a,
          mposb = _this$runner$getMachi.b,
          mposc = _this$runner$getMachi.c; // Work position


      var _this$runner$getWorkP = this.runner.getWorkPosition(),
          posx = _this$runner$getWorkP.x,
          posy = _this$runner$getWorkP.y,
          posz = _this$runner$getWorkP.z,
          posa = _this$runner$getWorkP.a,
          posb = _this$runner$getWorkP.b,
          posc = _this$runner$getWorkP.c; // Modal group


      var modal = this.runner.getModalGroup(); // Tool

      var tool = this.runner.getTool();
      return Object.assign(context || {}, _objectSpread({
        // User-defined global variables
        global: this.sharedContext,
        // Bounding box
        xmin: Number(context.xmin) || 0,
        xmax: Number(context.xmax) || 0,
        ymin: Number(context.ymin) || 0,
        ymax: Number(context.ymax) || 0,
        zmin: Number(context.zmin) || 0,
        zmax: Number(context.zmax) || 0,
        // Machine position
        mposx: Number(mposx) || 0,
        mposy: Number(mposy) || 0,
        mposz: Number(mposz) || 0,
        mposa: Number(mposa) || 0,
        mposb: Number(mposb) || 0,
        mposc: Number(mposc) || 0,
        // Work position
        posx: Number(posx) || 0,
        posy: Number(posy) || 0,
        posz: Number(posz) || 0,
        posa: Number(posa) || 0,
        posb: Number(posb) || 0,
        posc: Number(posc) || 0,
        // Modal group
        modal: {
          motion: modal.motion,
          wcs: modal.wcs,
          plane: modal.plane,
          units: modal.units,
          distance: modal.distance,
          feedrate: modal.feedrate,
          path: modal.path,
          spindle: modal.spindle,
          // M7 and M8 may be active at the same time, but a modal group violation might occur when issuing M7 and M8 together on the same line. Using the new line character (\n) to separate lines can avoid this issue.
          coolant: (0, _ensureArray["default"])(modal.coolant).join('\n')
        },
        // Tool
        tool: Number(tool) || 0
      }, _constants.GLOBAL_OBJECTS));
    }
  }, {
    key: "clearActionValues",
    value: function clearActionValues() {
      this.actionTime.energizeMotors = 0;
      this.actionTime.senderFinishTime = 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.timer.query) {
        clearInterval(this.timer.query);
        this.timer.query = null;
      }

      if (this.timer.energizeMotors) {
        clearInterval(this.timer.energizeMotors);
        this.timer.energizeMotors = null;
      }

      if (this.runner) {
        this.runner.removeAllListeners();
        this.runner = null;
      }

      this.sockets = {};

      if (this.connection) {
        this.connection = null;
      }

      if (this.event) {
        this.event = null;
      }

      if (this.feeder) {
        this.feeder = null;
      }

      if (this.sender) {
        this.sender = null;
      }

      if (this.workflow) {
        this.workflow = null;
      }
    }
  }, {
    key: "status",
    get: function get() {
      return {
        port: this.options.port,
        baudrate: this.options.baudrate,
        rtscts: this.options.rtscts,
        sockets: Object.keys(this.sockets),
        ready: this.ready,
        controller: {
          type: this.type,
          settings: this.settings,
          state: this.state,
          footer: this.runner.footer
        },
        feeder: this.feeder.toJSON(),
        sender: this.sender.toJSON(),
        workflow: {
          state: this.workflow.state
        }
      };
    }
  }, {
    key: "open",
    value: function open() {
      var _this3 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;
      var _this$options = this.options,
          port = _this$options.port,
          baudrate = _this$options.baudrate; // Assertion check

      if (this.isOpen()) {
        log.error("Cannot open serial port \"".concat(port, "\""));
        return;
      }

      this.connection.on('data', this.connectionEventListener.data);
      this.connection.on('close', this.connectionEventListener.close);
      this.connection.on('error', this.connectionEventListener.error);
      this.connection.open( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(err) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!err) {
                    _context2.next = 5;
                    break;
                  }

                  log.error("Error opening serial port \"".concat(port, "\":"), err);

                  _this3.emit('serialport:error', {
                    err: err,
                    port: port
                  });

                  callback(err); // notify error

                  return _context2.abrupt("return");

                case 5:
                  _this3.emit('serialport:open', {
                    port: port,
                    baudrate: baudrate,
                    controllerType: _this3.type,
                    inuse: true
                  }); // Emit a change event to all connected sockets


                  if (_this3.engine.io) {
                    _this3.engine.io.emit('serialport:change', {
                      port: port,
                      inuse: true
                    });
                  }

                  callback(); // register controller

                  log.debug("Connected to serial port \"".concat(port, "\""));

                  _this3.workflow.stop(); // Clear action values


                  _this3.clearActionValues();

                  if (_this3.sender.state.gcode) {
                    // Unload G-code
                    _this3.command('unload');
                  } // Wait for the bootloader to complete before sending commands


                  _context2.next = 14;
                  return (0, _delay["default"])(1000);

                case 14:
                  // Set ready flag to true
                  _this3.ready = true; // Initialize controller

                  _this3.initController();

                case 16:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "close",
    value: function close(callback) {
      var port = this.options.port; // Assertion check

      if (!this.connection) {
        var err = "Serial port \"".concat(port, "\" is not available");
        callback(new Error(err));
        return;
      } // Stop status query


      this.ready = false;
      this.emit('serialport:close', {
        port: port,
        inuse: false
      }); // Emit a change event to all connected sockets

      if (this.engine.io) {
        this.engine.io.emit('serialport:change', {
          port: port,
          inuse: false
        });
      }

      if (this.isClose()) {
        callback(null);
        return;
      }

      this.connection.removeAllListeners();
      this.connection.close(callback);
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.connection && this.connection.isOpen;
    }
  }, {
    key: "isClose",
    value: function isClose() {
      return !this.isOpen();
    }
  }, {
    key: "addConnection",
    value: function addConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Add socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = socket; //
      // Send data to newly connected client
      //

      if (this.isOpen()) {
        socket.emit('serialport:open', {
          port: this.options.port,
          baudrate: this.options.baudrate,
          controllerType: this.type,
          inuse: true
        });
      }

      if (!(0, _isEmpty2["default"])(this.settings)) {
        // controller settings
        socket.emit('controller:settings', _constants2.TINYG, this.settings);
        socket.emit('TinyG:settings', this.settings); // Backward compatibility
      }

      if (!(0, _isEmpty2["default"])(this.state)) {
        // controller state
        socket.emit('controller:state', _constants2.TINYG, this.state);
        socket.emit('TinyG:state', this.state); // Backward compatibility
      }

      if (this.feeder) {
        // feeder status
        socket.emit('feeder:status', this.feeder.toJSON());
      }

      if (this.sender) {
        // sender status
        socket.emit('sender:status', this.sender.toJSON());
        var _this$sender$state6 = this.sender.state,
            name = _this$sender$state6.name,
            gcode = _this$sender$state6.gcode,
            context = _this$sender$state6.context;

        if (gcode) {
          socket.emit('gcode:load', name, gcode, context);
        }
      }

      if (this.workflow) {
        // workflow state
        socket.emit('workflow:state', this.workflow.state);
      }
    }
  }, {
    key: "removeConnection",
    value: function removeConnection(socket) {
      if (!socket) {
        log.error('The socket parameter is not specified');
        return;
      }

      log.debug("Remove socket connection: id=".concat(socket.id));
      this.sockets[socket.id] = undefined;
      delete this.sockets[socket.id];
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this4 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      Object.keys(this.sockets).forEach(function (id) {
        var socket = _this4.sockets[id];
        socket.emit.apply(socket, [eventName].concat(args));
      });
    } // https://github.com/synthetos/g2/wiki/Job-Exception-Handling
    // Character    Operation       Description
    // !            Feedhold        Start a feedhold. Ignored if already in a feedhold
    // ~            End Feedhold    Resume from feedhold. Ignored if not in feedhold
    // %            Queue Flush     Flush remaining moves during feedhold. Ignored if not in feedhold
    // ^d           Kill Job        Trigger ALARM to kill current job. Send {clear:n}, M2 or M30 to end ALARM state
    // ^x           Reset Board     Perform hardware reset to restart the board

  }, {
    key: "command",
    value: function command(cmd) {
      var _this5 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var handler = {
        'gcode:load': function gcodeLoad() {
          var name = args[0],
              gcode = args[1],
              _args$ = args[2],
              context = _args$ === void 0 ? {} : _args$,
              _args$2 = args[3],
              callback = _args$2 === void 0 ? noop : _args$2;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          } // G4 P0 or P with a very small value will empty the planner queue and then
          // respond with an ok when the dwell is complete. At that instant, there will
          // be no queued motions, as long as no more commands were sent after the G4.
          // This is the fastest way to do it without having to check the status reports.


          var dwell = '%wait ; Wait for the planner to empty';

          var ok = _this5.sender.load(name, gcode + '\n' + dwell, context);

          if (!ok) {
            callback(new Error("Invalid G-code: name=".concat(name)));
            return;
          }

          _this5.emit('gcode:load', name, gcode, context);

          _this5.event.trigger('gcode:load');

          log.debug("Load G-code: name=\"".concat(_this5.sender.state.name, "\", size=").concat(_this5.sender.state.gcode.length, ", total=").concat(_this5.sender.state.total));

          _this5.workflow.stop();

          callback(null, _this5.sender.toJSON());
        },
        'gcode:unload': function gcodeUnload() {
          _this5.workflow.stop(); // Sender


          _this5.sender.unload();

          _this5.emit('gcode:unload');

          _this5.event.trigger('gcode:unload');
        },
        'start': function start() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this5.command('gcode:start');
        },
        'gcode:start': function gcodeStart() {
          _this5.event.trigger('gcode:start');

          _this5.workflow.start(); // Feeder


          _this5.feeder.reset(); // Sender


          _this5.sender.next();
        },
        'stop': function stop() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this5.command.apply(_this5, ['gcode:stop'].concat(args));
        },
        // @param {object} options The options object.
        // @param {boolean} [options.force] Whether to force stop a G-code program. Defaults to false.
        'gcode:stop': function gcodeStop() {
          _this5.event.trigger('gcode:stop');

          _this5.workflow.stop();

          var options = args[0];

          var _options2 = _objectSpread({}, options),
              _options2$force = _options2.force,
              force = _options2$force === void 0 ? false : _options2$force;

          if (force) {
            var firmwareBuild = (0, _ensureType.ensureNumber)((0, _get2["default"])(_this5.settings, 'fb'));

            if (firmwareBuild >= 101) {
              // https://github.com/synthetos/g2/releases/tag/101.02
              // * Added explicit Job Kill ^d - has the effect of an M30 (program end)
              _this5.writeln('\x04'); // kill job (^d)

            } else if (firmwareBuild >= 100) {
              _this5.writeln('\x04'); // kill job (^d)


              _this5.writeln('M30'); // end of program

            } else {
              // https://github.com/synthetos/g2/wiki/Feedhold,-Resume,-and-Other-Simple-Commands#jogging-using-feedhold-and-queue-flush
              // Send a ! to stop movement immediately.
              // Send a % to flush remaining moves from planner buffer.
              _this5.writeln('!'); // feedhold


              _this5.writeln('%'); // queue flush


              _this5.writeln('M30'); // end of program

            }
          }

          _this5.writeln('{"qr":""}'); // queue report

        },
        'pause': function pause() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this5.command('gcode:pause');
        },
        'gcode:pause': function gcodePause() {
          _this5.event.trigger('gcode:pause');

          _this5.workflow.pause();

          _this5.writeln('!'); // feedhold


          _this5.writeln('{"qr":""}'); // queue report

        },
        'resume': function resume() {
          log.warn("Warning: The \"".concat(cmd, "\" command is deprecated and will be removed in a future release."));

          _this5.command('gcode:resume');
        },
        'gcode:resume': function gcodeResume() {
          _this5.event.trigger('gcode:resume');

          _this5.writeln('~'); // cycle start


          _this5.workflow.resume();

          _this5.writeln('{"qr":""}'); // queue report

        },
        'feeder:feed': function feederFeed() {
          var commands = args[0],
              _args$3 = args[1],
              context = _args$3 === void 0 ? {} : _args$3;

          _this5.command('gcode', commands, context);
        },
        'feeder:start': function feederStart() {
          if (_this5.workflow.state === _Workflow.WORKFLOW_STATE_RUNNING) {
            return;
          }

          _this5.writeln('~'); // cycle start


          _this5.writeln('{"qr":""}'); // queue report


          _this5.feeder.unhold();

          _this5.feeder.next();
        },
        'feeder:stop': function feederStop() {
          _this5.feeder.reset();
        },
        'feedhold': function feedhold() {
          _this5.event.trigger('feedhold');

          _this5.writeln('!'); // feedhold


          _this5.writeln('{"qr":""}'); // queue report

        },
        'cyclestart': function cyclestart() {
          _this5.event.trigger('cyclestart');

          _this5.writeln('~'); // cycle start


          _this5.writeln('{"qr":""}'); // queue report

        },
        'statusreport': function statusreport() {
          _this5.writeln('{"sr":null}');
        },
        'homing': function homing() {
          _this5.event.trigger('homing');

          _this5.writeln('G28.2 X0 Y0 Z0');
        },
        'sleep': function sleep() {
          _this5.event.trigger('sleep'); // Not supported

        },
        'unlock': function unlock() {
          _this5.writeln('{clear:null}'); // alarm clear

        },
        'reset': function reset() {
          _this5.workflow.stop();

          _this5.feeder.reset();

          _this5.write('\x18'); // reset board (^x)

        },
        // Feed Overrides
        // @param {number} value A percentage value between 5 and 200. A value of zero will reset to 100%.
        'feedOverride': function feedOverride() {
          var value = args[0];
          var mfo = _this5.runner.settings.mfo;

          if (value === 0) {
            mfo = 1;
          } else if (mfo * 100 + value > 200) {
            mfo = 2;
          } else if (mfo * 100 + value < 5) {
            mfo = 0.05;
          } else {
            mfo = (mfo * 100 + value) / 100;
          }

          _this5.command('gcode', "{mfo:".concat(mfo, "}"));
        },
        // Spindle Speed Overrides
        // @param {number} value A percentage value between 5 and 200. A value of zero will reset to 100%.
        'spindleOverride': function spindleOverride() {
          var value = args[0];
          var sso = _this5.runner.settings.sso;

          if (value === 0) {
            sso = 1;
          } else if (sso * 100 + value > 200) {
            sso = 2;
          } else if (sso * 100 + value < 5) {
            sso = 0.05;
          } else {
            sso = (sso * 100 + value) / 100;
          }

          _this5.command('gcode', "{sso:".concat(sso, "}"));
        },
        // Rapid Overrides
        'rapidOverride': function rapidOverride() {
          var value = args[0];

          if (value === 0 || value === 100) {
            _this5.command('gcode', '{mto:1}');
          } else if (value === 50) {
            _this5.command('gcode', '{mto:0.5}');
          } else if (value === 25) {
            _this5.command('gcode', '{mto:0.25}');
          }
        },
        'energizeMotors:on': function energizeMotorsOn() {
          var _this5$state$mt = _this5.state.mt,
              mt = _this5$state$mt === void 0 ? 0 : _this5$state$mt;

          if (_this5.timer.energizeMotors || !mt) {
            return;
          }

          _this5.command('gcode', '{me:0}');

          _this5.command('gcode', '{pwr:n}'); // Setup a timer to energize motors up to 30 minutes


          _this5.timer.energizeMotors = setInterval(function () {
            var now = new Date().getTime();

            if (_this5.actionTime.energizeMotors <= 0) {
              _this5.actionTime.energizeMotors = now;
            }

            var timespan = Math.abs(now - _this5.actionTime.energizeMotors);
            var toleranceTime = 30 * 60 * 1000; // 30 minutes

            if (timespan > toleranceTime) {
              _this5.command('energizeMotors:off');

              return;
            }

            _this5.command('gcode', '{me:0}');

            _this5.command('gcode', '{pwr:n}');
          }, mt * 1000 - 500);
        },
        'energizeMotors:off': function energizeMotorsOff() {
          if (_this5.timer.energizeMotors) {
            clearInterval(_this5.timer.energizeMotors);
            _this5.timer.energizeMotors = null;
          }

          _this5.actionTime.energizeMotors = 0;

          _this5.command('gcode', '{md:0}');

          _this5.command('gcode', '{pwr:n}');
        },
        'lasertest:on': function lasertestOn() {
          var _args$4 = args[0],
              power = _args$4 === void 0 ? 0 : _args$4,
              _args$5 = args[1],
              duration = _args$5 === void 0 ? 0 : _args$5,
              _args$6 = args[2],
              maxS = _args$6 === void 0 ? 1000 : _args$6;
          var commands = ['M3S' + (0, _ensurePositiveNumber["default"])(maxS * (power / 100))];

          if (duration > 0) {
            commands.push('G4P' + (0, _ensurePositiveNumber["default"])(duration / 1000));
            commands.push('M5S0');
          }

          _this5.command('gcode', commands);
        },
        'lasertest:off': function lasertestOff() {
          var commands = ['M5S0'];

          _this5.command('gcode', commands);
        },
        'gcode': function gcode() {
          var commands = args[0],
              context = args[1];
          var data = (0, _ensureArray["default"])(commands).join('\n').split(/\r?\n/).filter(function (line) {
            if (typeof line !== 'string') {
              return false;
            }

            return line.trim().length > 0;
          });

          _this5.feeder.feed(data, context);

          if (!_this5.feeder.isPending()) {
            _this5.feeder.next();
          }
        },
        'macro:run': function macroRun() {
          var id = args[0],
              _args$7 = args[1],
              context = _args$7 === void 0 ? {} : _args$7,
              _args$8 = args[2],
              callback = _args$8 === void 0 ? noop : _args$8;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this5.event.trigger('macro:run');

          _this5.command('gcode', macro.content, context);

          callback(null);
        },
        'macro:load': function macroLoad() {
          var id = args[0],
              _args$9 = args[1],
              context = _args$9 === void 0 ? {} : _args$9,
              _args$10 = args[2],
              callback = _args$10 === void 0 ? noop : _args$10;

          if (typeof context === 'function') {
            callback = context;
            context = {};
          }

          var macros = _configstore["default"].get('macros');

          var macro = (0, _find2["default"])(macros, {
            id: id
          });

          if (!macro) {
            log.error("Cannot find the macro: id=".concat(id));
            return;
          }

          _this5.event.trigger('macro:load');

          _this5.command('gcode:load', macro.name, macro.content, context, callback);
        },
        'watchdir:load': function watchdirLoad() {
          var file = args[0],
              _args$11 = args[1],
              callback = _args$11 === void 0 ? noop : _args$11;
          var context = {}; // empty context

          _monitor["default"].readFile(file, function (err, data) {
            if (err) {
              callback(err);
              return;
            }

            _this5.command('gcode:load', file, data, context, callback);
          });
        }
      }[cmd];

      if (!handler) {
        log.error("Unknown command: ".concat(cmd));
        return;
      }

      handler();
    }
  }, {
    key: "write",
    value: function write(data, context) {
      // Assertion check
      if (this.isClose()) {
        log.error("Serial port \"".concat(this.options.port, "\" is not accessible"));
        return;
      }

      this.emit('serialport:write', data, _objectSpread(_objectSpread({}, context), {}, {
        source: _constants.WRITE_SOURCE_CLIENT
      }));
      this.connection.write(data);
      log.silly("> ".concat(data));
    }
  }, {
    key: "writeln",
    value: function writeln(data, context) {
      this.write(data + '\n', context);
    }
  }]);

  return TinyGController;
}();

var _default = TinyGController;
exports["default"] = _default;