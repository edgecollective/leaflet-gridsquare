"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLevel = exports.levels = exports.getLevel = exports["default"] = void 0;

var _util = _interopRequireDefault(require("util"));

var _chalk = _interopRequireDefault(require("chalk"));

var _winston = _interopRequireDefault(require("winston"));

var _settings = _interopRequireDefault(require("../config/settings"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
var getStackTrace = function getStackTrace() {
  var obj = {};
  Error.captureStackTrace(obj, getStackTrace);
  return (obj.stack || '').split('\n');
};

var VERBOSITY_MAX = 3; // -vvv

var _winston$format = _winston["default"].format,
    combine = _winston$format.combine,
    colorize = _winston$format.colorize,
    timestamp = _winston$format.timestamp,
    printf = _winston$format.printf; // https://github.com/winstonjs/winston/blob/master/README.md#creating-your-own-logger

var logger = _winston["default"].createLogger({
  exitOnError: false,
  level: _settings["default"].winston.level,
  silent: false,
  transports: [new _winston["default"].transports.Console({
    format: combine(colorize(), timestamp(), printf(function (log) {
      return "".concat(log.timestamp, " - ").concat(log.level, " ").concat(log.message);
    })),
    handleExceptions: true
  })]
}); // https://github.com/winstonjs/winston/blob/master/README.md#logging-levels
// npm logging levels are prioritized from 0 to 5 (highest to lowest):


var levels = ['error', // 0
'warn', // 1
'info', // 2
'verbose', // 3
'debug', // 4
'silly' // 5
];
exports.levels = levels;

var getLevel = function getLevel() {
  return logger.level;
};

exports.getLevel = getLevel;

var setLevel = function setLevel(level) {
  logger.level = level;
};

exports.setLevel = setLevel;

var _default = function _default() {
  var namespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  namespace = String(namespace);
  return levels.reduce(function (acc, level) {
    acc[level] = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (_settings["default"].verbosity >= VERBOSITY_MAX && level !== 'silly') {
        args = args.concat(getStackTrace()[2]);
      }

      return namespace.length > 0 ? logger[level](_chalk["default"].cyan(namespace) + ' ' + _util["default"].format.apply(_util["default"], _toConsumableArray(args))) : logger[level](_util["default"].format.apply(_util["default"], _toConsumableArray(args)));
    };

    return acc;
  }, {});
};

exports["default"] = _default;