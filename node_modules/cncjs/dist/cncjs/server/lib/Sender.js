"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.SP_TYPE_SEND_RESPONSE = exports.SP_TYPE_CHAR_COUNTING = void 0;

var _events = _interopRequireDefault(require("events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SP_TYPE_SEND_RESPONSE = 0;
exports.SP_TYPE_SEND_RESPONSE = SP_TYPE_SEND_RESPONSE;
var SP_TYPE_CHAR_COUNTING = 1;
exports.SP_TYPE_CHAR_COUNTING = SP_TYPE_CHAR_COUNTING;

var noop = function noop() {};

var SPSendResponse = /*#__PURE__*/function () {
  function SPSendResponse(options) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    _classCallCheck(this, SPSendResponse);

    _defineProperty(this, "callback", null);

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (typeof callback === 'function') {
      this.callback = callback;
    }
  }

  _createClass(SPSendResponse, [{
    key: "process",
    value: function process() {
      this.callback && this.callback(this);
    }
  }, {
    key: "clear",
    value: function clear() {// Do nothing
    }
  }, {
    key: "type",
    get: function get() {
      return SP_TYPE_SEND_RESPONSE;
    }
  }]);

  return SPSendResponse;
}();

var SPCharCounting = /*#__PURE__*/function () {
  function SPCharCounting(options) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    _classCallCheck(this, SPCharCounting);

    _defineProperty(this, "callback", null);

    _defineProperty(this, "state", {
      bufferSize: 128,
      // Defaults to 128
      dataLength: 0,
      queue: [],
      line: ''
    });

    if (typeof options === 'function') {
      callback = options;
      options = {};
    } // bufferSize


    var bufferSize = Number(options.bufferSize);

    if (bufferSize && bufferSize > 0) {
      this.state.bufferSize = bufferSize;
    }

    if (typeof callback === 'function') {
      this.callback = callback;
    }
  }

  _createClass(SPCharCounting, [{
    key: "process",
    value: function process() {
      this.callback && this.callback(this);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.state.bufferSize = 128; // Defaults to 128

      this.state.dataLength = 0;
      this.state.queue = [];
      this.state.line = '';
    }
  }, {
    key: "clear",
    value: function clear() {
      this.state.dataLength = 0;
      this.state.queue = [];
      this.state.line = '';
    }
  }, {
    key: "type",
    get: function get() {
      return SP_TYPE_CHAR_COUNTING;
    }
  }, {
    key: "bufferSize",
    get: function get() {
      return this.state.bufferSize;
    },
    set: function set(bufferSize) {
      if (bufferSize === void 0) {
        bufferSize = 0;
      }

      bufferSize = Number(bufferSize);

      if (!bufferSize) {
        return;
      } // The buffer size cannot be reduced below the size of the data within the buffer.


      this.state.bufferSize = Math.max(bufferSize, this.state.dataLength);
    }
  }, {
    key: "dataLength",
    get: function get() {
      return this.state.dataLength;
    },
    set: function set(dataLength) {
      this.state.dataLength = dataLength;
    }
  }, {
    key: "queue",
    get: function get() {
      return this.state.queue;
    },
    set: function set(queue) {
      this.state.queue = queue;
    }
  }, {
    key: "line",
    get: function get() {
      return this.state.line;
    },
    set: function set(line) {
      this.state.line = line;
    }
  }]);

  return SPCharCounting;
}();

var Sender = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(Sender, _events$EventEmitter);

  var _super = _createSuper(Sender);

  // streaming protocol
  // @param {number} [type] Streaming protocol type. 0 for send-response, 1 for character-counting.
  // @param {object} [options] The options object.
  // @param {number} [options.bufferSize] The buffer size used in character-counting streaming protocol. Defaults to 127.
  // @param {function} [options.dataFilter] A function to be used to handle the data. The function accepts two arguments: The data to be sent to the controller, and the context.
  function Sender() {
    var _this;

    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SP_TYPE_SEND_RESPONSE;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Sender);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "sp", null);

    _defineProperty(_assertThisInitialized(_this), "state", {
      hold: false,
      holdReason: null,
      name: '',
      gcode: '',
      context: {},
      lines: [],
      total: 0,
      sent: 0,
      received: 0,
      startTime: 0,
      finishTime: 0,
      elapsedTime: 0,
      remainingTime: 0
    });

    _defineProperty(_assertThisInitialized(_this), "stateChanged", false);

    _defineProperty(_assertThisInitialized(_this), "dataFilter", null);

    if (typeof options.dataFilter === 'function') {
      _this.dataFilter = options.dataFilter;
    } // character-counting


    if (type === SP_TYPE_CHAR_COUNTING) {
      _this.sp = new SPCharCounting(options, function (sp) {
        if (sp.queue.length > 0) {
          var lineLength = sp.queue.shift();
          sp.dataLength -= lineLength;
        }

        while (!_this.state.hold && _this.state.sent < _this.state.total) {
          // Remove leading and trailing whitespace from both ends of a string
          sp.line = sp.line || _this.state.lines[_this.state.sent].trim();

          if (_this.dataFilter) {
            sp.line = _this.dataFilter(sp.line, _this.state.context) || '';
          } // The newline character (\n) consumed the RX buffer space


          if (sp.line.length > 0 && sp.dataLength + sp.line.length + 1 >= sp.bufferSize) {
            break;
          }

          _this.state.sent++;

          _this.emit('change');

          if (sp.line.length === 0) {
            _this.ack(); // ack empty line


            continue;
          }

          var line = sp.line + '\n';
          sp.line = '';
          sp.dataLength += line.length;
          sp.queue.push(line.length);

          _this.emit('data', line, _this.state.context);
        }
      });
    } // send-response


    if (type === SP_TYPE_SEND_RESPONSE) {
      _this.sp = new SPSendResponse(options, function (sp) {
        while (!_this.state.hold && _this.state.sent < _this.state.total) {
          // Remove leading and trailing whitespace from both ends of a string
          var line = _this.state.lines[_this.state.sent].trim();

          if (_this.dataFilter) {
            line = _this.dataFilter(line, _this.state.context) || '';
          }

          _this.state.sent++;

          _this.emit('change');

          if (line.length === 0) {
            _this.ack(); // ack empty line


            continue;
          }

          _this.emit('data', line + '\n', _this.state.context);

          break;
        }
      });
    }

    _this.on('change', function () {
      _this.stateChanged = true;
    });

    return _this;
  }

  _createClass(Sender, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        sp: this.sp.type,
        hold: this.state.hold,
        holdReason: this.state.holdReason,
        name: this.state.name,
        context: this.state.context,
        size: this.state.gcode.length,
        total: this.state.total,
        sent: this.state.sent,
        received: this.state.received,
        startTime: this.state.startTime,
        finishTime: this.state.finishTime,
        elapsedTime: this.state.elapsedTime,
        remainingTime: this.state.remainingTime
      };
    }
  }, {
    key: "hold",
    value: function hold(reason) {
      if (this.state.hold) {
        return;
      }

      this.state.hold = true;
      this.state.holdReason = reason;
      this.emit('hold');
      this.emit('change');
    }
  }, {
    key: "unhold",
    value: function unhold() {
      if (!this.state.hold) {
        return;
      }

      this.state.hold = false;
      this.state.holdReason = null;
      this.emit('unhold');
      this.emit('change');
    } // @return {boolean} Returns true on success, false otherwise.

  }, {
    key: "load",
    value: function load(name) {
      var gcode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (typeof gcode !== 'string' || !gcode) {
        return false;
      }

      var lines = gcode.split('\n').filter(function (line) {
        return line.trim().length > 0;
      });

      if (this.sp) {
        this.sp.clear();
      }

      this.state.hold = false;
      this.state.holdReason = null;
      this.state.name = name;
      this.state.gcode = gcode;
      this.state.context = context;
      this.state.lines = lines;
      this.state.total = this.state.lines.length;
      this.state.sent = 0;
      this.state.received = 0;
      this.state.startTime = 0;
      this.state.finishTime = 0;
      this.state.elapsedTime = 0;
      this.state.remainingTime = 0;
      this.emit('load', name, gcode, context);
      this.emit('change');
      return true;
    }
  }, {
    key: "unload",
    value: function unload() {
      if (this.sp) {
        this.sp.clear();
      }

      this.state.hold = false;
      this.state.holdReason = null;
      this.state.name = '';
      this.state.gcode = '';
      this.state.context = {};
      this.state.lines = [];
      this.state.total = 0;
      this.state.sent = 0;
      this.state.received = 0;
      this.state.startTime = 0;
      this.state.finishTime = 0;
      this.state.elapsedTime = 0;
      this.state.remainingTime = 0;
      this.emit('unload');
      this.emit('change');
    } // Tells the sender an acknowledgement has received.
    // @return {boolean} Returns true on success, false otherwise.

  }, {
    key: "ack",
    value: function ack() {
      if (!this.state.gcode) {
        return false;
      }

      if (this.state.received >= this.state.sent) {
        return false;
      }

      this.state.received++;
      this.emit('change');
      return true;
    } // Tells the sender to send more data.
    // @return {boolean} Returns true on success, false otherwise.

  }, {
    key: "next",
    value: function next() {
      if (!this.state.gcode) {
        return false;
      }

      var now = new Date().getTime();

      if (this.state.total > 0 && this.state.sent === 0) {
        this.state.startTime = now;
        this.state.finishTime = 0;
        this.state.elapsedTime = 0;
        this.state.remainingTime = 0;
        this.emit('start', this.state.startTime);
        this.emit('change');
      }

      if (this.sp) {
        this.sp.process();
      } // Elapsed Time


      this.state.elapsedTime = now - this.state.startTime; // Make a 1 second delay before estimating the remaining time

      if (this.state.elapsedTime >= 1000 && this.state.received > 0) {
        var timePerCode = this.state.elapsedTime / this.state.received;
        this.state.remainingTime = timePerCode * this.state.total - this.state.elapsedTime;
      }

      if (this.state.received >= this.state.total) {
        if (this.state.finishTime === 0) {
          // avoid issue 'end' multiple times
          this.state.finishTime = now;
          this.emit('end', this.state.finishTime);
          this.emit('change');
        }
      }

      return true;
    } // Rewinds the internal array pointer.
    // @return {boolean} Returns true on success, false otherwise.

  }, {
    key: "rewind",
    value: function rewind() {
      if (!this.state.gcode) {
        return false;
      }

      if (this.sp) {
        this.sp.clear();
      }

      this.state.hold = false; // clear hold off state

      this.state.holdReason = null;
      this.state.sent = 0;
      this.state.received = 0;
      this.emit('change');
      return true;
    } // Checks if there are any state changes. It also clears the stateChanged flag.
    // @return {boolean} Returns true on state changes, false otherwise.

  }, {
    key: "peek",
    value: function peek() {
      var stateChanged = this.stateChanged;
      this.stateChanged = false;
      return stateChanged;
    }
  }]);

  return Sender;
}(_events["default"].EventEmitter);

var _default = Sender;
exports["default"] = _default;