"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _set2 = _interopRequireDefault(require("lodash/set"));

var _esprima = require("esprima");

var _evaluateExpression = _interopRequireDefault(require("./evaluate-expression"));

var _logger = _interopRequireDefault(require("./logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var log = (0, _logger["default"])('evaluate-assignment-expression');

var isStaticMemberExpression = function isStaticMemberExpression(node) {
  return _typeof(node) === 'object' && node.type === 'MemberExpression' && !node.computed;
};

var isComputedMemberExpression = function isComputedMemberExpression(node) {
  return _typeof(node) === 'object' && node.type === 'MemberExpression' && !!node.computed;
};

var lookupObjectPath = function lookupObjectPath(node, vars) {
  if (!node) {
    return [];
  }
  /*
   * Expression: 'x = value'
   *
   * Identifier { type: 'Identifier', name: 'x' }
   */


  if (node.type === 'Identifier') {
    return [node.name];
  }

  if (isComputedMemberExpression(node)) {
    return [].concat(_toConsumableArray(lookupObjectPath(node.object, vars)), [(0, _evaluateExpression["default"])(node.property, vars)]);
  }

  if (isStaticMemberExpression(node)) {
    /*
     * Expression: 'x.y = value'
     *
     * StaticMemberExpression {
     *   type: 'MemberExpression',
     *   computed: false,
     *   object: Identifier { type: 'Identifier', name: 'x' },
     *   property: Identifier { type: 'Identifier', name: 'y' }
     * }
     *
     * Expression: 'x[y] = value'
     *
     * ComputedMemberExpression {
     *   type: 'MemberExpression',
     *   computed: true,
     *   object: Identifier { type: 'Identifier', name: 'x' },
     *   property: Identifier { type: 'Identifier', name: 'y' }
     * }
     */
    if (node.property.type === 'Identifier') {
      return [].concat(_toConsumableArray(lookupObjectPath(node.object, vars)), [node.property.name]);
    }
    /*
     * Expression: 'x["y"] = value'
     *
     * ComputedMemberExpression {
     *   type: 'MemberExpression',
     *   computed: true,
     *   object: Identifier { type: 'Identifier', name: 'x' },
     *   property: Literal { type: 'Literal', value: 'y', raw: '"y"' }
     * }
     */


    if (node.property.type === 'Literal') {
      return [].concat(_toConsumableArray(lookupObjectPath(node.object, vars)), [node.property.value]);
    }

    return [].concat(_toConsumableArray(lookupObjectPath(node.object, vars)), [(0, _evaluateExpression["default"])(node.property, vars)]);
  }

  return [node.name];
};

var walkAssignmentExpression = function walkAssignmentExpression(node, vars) {
  console.assert(node && node.type === 'AssignmentExpression');
  var path = lookupObjectPath(node.left, vars);

  if (path) {
    var value = (0, _evaluateExpression["default"])(node.right, vars);
    (0, _set2["default"])(vars, path, value);
  }
};

var walkSequenceExpression = function walkSequenceExpression(node, vars) {
  console.assert(node && node.type === 'SequenceExpression');
  node.expressions.forEach(function (expr) {
    if (expr.type === 'AssignmentExpression') {
      walkAssignmentExpression(expr, vars);
      return;
    }

    (0, _evaluateExpression["default"])(expr, vars);
  });
};

var evaluateAssignmentExpression = function evaluateAssignmentExpression(src) {
  var vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!src) {
    return vars;
  }

  try {
    var ast = (0, _esprima.parse)(src).body[0].expression;

    if (ast.type === 'AssignmentExpression') {
      walkAssignmentExpression(ast, vars);
    } else if (ast.type === 'SequenceExpression') {
      walkSequenceExpression(ast, vars);
    } else {
      (0, _evaluateExpression["default"])(ast, vars);
    }
  } catch (e) {
    log.error("src=\"".concat(src, "\", vars=").concat(JSON.stringify(vars)));
    log.error(e);
  }

  return vars;
};

var _default = evaluateAssignmentExpression;
exports["default"] = _default;