"use strict";

require("@babel/polyfill");

var _electron = require("electron");

var _electronStore = _interopRequireDefault(require("electron-store"));

var _chalk = _interopRequireDefault(require("chalk"));

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _menuTemplate = _interopRequireDefault(require("./electron-app/menu-template"));

var _WindowManager = _interopRequireDefault(require("./electron-app/WindowManager"));

var _serverCli = _interopRequireDefault(require("./server-cli"));

var _package = _interopRequireDefault(require("./package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// The selection menu
var selectionMenu = _electron.Menu.buildFromTemplate([{
  role: 'copy'
}, {
  type: 'separator'
}, {
  role: 'selectall'
}]); // The input menu


var inputMenu = _electron.Menu.buildFromTemplate([{
  role: 'undo'
}, {
  role: 'redo'
}, {
  type: 'separator'
}, {
  role: 'cut'
}, {
  role: 'copy'
}, {
  role: 'paste'
}, {
  type: 'separator'
}, {
  role: 'selectall'
}]);

var windowManager = null;

var main = function main() {
  // https://github.com/electron/electron/blob/master/docs/api/app.md#apprequestsingleinstancelock
  var gotSingleInstanceLock = _electron.app.requestSingleInstanceLock();

  var shouldQuitImmediately = !gotSingleInstanceLock;

  if (shouldQuitImmediately) {
    _electron.app.quit();

    return;
  }

  _electron.app.on('second-instance', function (event, commandLine, workingDirectory) {
    // Someone tried to run a second instance, we should focus our window.
    if (!windowManager) {
      return;
    }

    var window = windowManager.getWindow();

    if (window) {
      if (window.isMinimized()) {
        window.restore();
      }

      window.focus();
    }
  });

  var store = new _electronStore["default"](); // Create the user data directory if it does not exist

  var userData = _electron.app.getPath('userData');

  _mkdirp["default"].sync(userData);

  _electron.app.on('ready', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var res, _res, address, port, mountPoints, menu, url, bounds, options, window;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0, _serverCli["default"])();

          case 3:
            res = _context.sent;
            _res = _objectSpread({}, res), address = _res.address, port = _res.port, mountPoints = _res.mountPoints;

            if (address && port) {
              _context.next = 8;
              break;
            }

            console.error('Unable to start the server at ' + _chalk["default"].cyan("http://".concat(address, ":").concat(port)));
            return _context.abrupt("return");

          case 8:
            menu = _electron.Menu.buildFromTemplate((0, _menuTemplate["default"])({
              address: address,
              port: port,
              mountPoints: mountPoints
            }));

            _electron.Menu.setApplicationMenu(menu);

            windowManager = new _WindowManager["default"]();
            url = "http://".concat(address, ":").concat(port); // The bounds is a rectangle object with the following properties:
            // * `x` Number - The x coordinate of the origin of the rectangle.
            // * `y` Number - The y coordinate of the origin of the rectangle.
            // * `width` Number - The width of the rectangle.
            // * `height` Number - The height of the rectangle.

            bounds = _objectSpread({
              width: 1280,
              // Defaults to 1280
              height: 768
            }, store.get('bounds'));
            options = _objectSpread(_objectSpread({}, bounds), {}, {
              title: "".concat(_package["default"].name, " ").concat(_package["default"].version)
            });
            window = windowManager.openWindow(url, options); // Save window size and position

            window.on('close', function () {
              store.set('bounds', window.getBounds());
            }); // https://github.com/electron/electron/issues/4068#issuecomment-274159726

            window.webContents.on('context-menu', function (event, props) {
              var selectionText = props.selectionText,
                  isEditable = props.isEditable;

              if (isEditable) {
                // Shows an input menu if editable
                inputMenu.popup(window);
              } else if (selectionText && String(selectionText).trim() !== '') {
                // Shows a selection menu if there was selected text
                selectionMenu.popup(window);
              }
            });
            _context.next = 22;
            break;

          case 19:
            _context.prev = 19;
            _context.t0 = _context["catch"](0);
            console.error('Error:', _context.t0);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 19]]);
  })));
};

main();